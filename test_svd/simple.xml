<?xml version="1.0" encoding="utf-8"?>
<!-- File naming: <part/series name>.svd -->
<!--
  Copyright (C) 2012-2014 ARM Limited. All rights reserved.

  Purpose: System Viewer Description (SVD) Example (Schema Version 1.1)
           This is a description of a none-existent and incomplete device
		   for demonstration purposes only.
		   
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
   - Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
   - Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.
   - Neither the name of ARM nor the names of its contributors may be used 
     to endorse or promote products derived from this software without 
     specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.
 -->
<device schemaVersion="1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="svd.xsd">
	<vendor>Infineon</vendor>
	<!-- device vendor name -->
	<vendorID>IFX</vendorID>
	<!-- device vendor short name -->
	<name>ARM_Example</name>
	<!-- name of part-->
	<series>ARMCM3</series>
	<!-- device series the device belongs to -->
	<version>1.2</version>
	<!-- version of this description, adding CMSIS-SVD 1.1 tags -->
	<description>SVD Test for Rust PAC generator</description>
	<!-- this license text will appear in header file. \n force line breaks -->
	<licenseText>Test license\n </licenseText>
	<cpu>
		<!-- details about the cpu embedded in the device -->
		<name>CM3</name>
		<revision>r1p0</revision>
		<endian>little</endian>
		<mpuPresent>true</mpuPresent>
		<fpuPresent>true</fpuPresent>
		<nvicPrioBits>3</nvicPrioBits>
		<vendorSystickConfig>false</vendorSystickConfig>
	</cpu>
	<addressUnitBits>8</addressUnitBits>
	<!-- byte addressable memory -->
	<width>32</width>
	<!-- bus width is 32 bits -->
	<!-- default settings implicitly inherited by subsequent sections -->
	<!-- this is the default size (number of bits) of all peripherals
                                                                       and register that do not define "size" themselves -->
	<size>32</size>
	<access>read-write</access>
	<!-- default access permission for all subsequent registers -->
	<resetValue>0x00000000</resetValue>
	<!-- by default all bits of the registers are initialized to 0 on reset -->
	<resetMask>0xFFFFFFFF</resetMask>
	<!-- by default all 32Bits of the registers are used -->
	<peripherals>
		<!-- Timer 0 -->
		<peripheral>
			<name>TIMER</name>
			<version>1.0</version>
			<description>Description of peripheral</description>
			<groupName>TIMER</groupName>
			<baseAddress>0x40010000</baseAddress>
			<access>read-write</access>
			<addressBlock>
				<offset>0</offset>
				<size>0x100000</size>
				<usage>registers</usage>
			</addressBlock>
			<interrupt>
				<name>TIMER0</name>
				<description>Timer 0 interrupt</description>
				<value>0</value>
			</interrupt>
			<registers>
				<register>
					<name>BITFIELD_REG</name>
					<description>Register to test basic bitfield features</description>
					<addressOffset>0x00</addressOffset>
					<access>read-write</access>
					<resetMask>0x1337F7F</resetMask>
					<fields>
						<field>
							<name>BoolR</name>
							<description>Boolean Bitfield Read Only</description>
							<bitRange>[0:0]</bitRange>
							<access>read-only</access>
						</field>
						<field>
							<name>BoolW</name>
							<description>Boolean Bitfield Write Only</description>
							<bitRange>[1:1]</bitRange>
							<access>write-only</access>
						</field>
						<field>
							<name>BoolRW</name>
							<description>Boolean bitfield Read Write</description>
							<bitRange>[2:2]</bitRange>
							<access>read-write</access>
						</field>
						<field>
							<name>BitfieldR</name>
							<description>Raw Bitfield Read Only</description>
							<bitRange>[5:3]</bitRange>
							<access>read-only</access>
						</field>
						<field>
							<name>BitfieldW</name>
							<description>Bitfield Raw Write Only</description>
							<bitRange>[7:6]</bitRange>
							<access>write-only</access>
						</field>
						<field>
							<name>BitfieldRW</name>
							<description>BitField Raw Read Write</description>
							<bitRange>[11:8]</bitRange>
							<access>read-write</access>
						</field>
						<field>
							<name>BitfieldEnumerated</name>
							<description>Bitfield with enumerated field</description>
							<bitRange>[15:12]</bitRange>
							<access>read-write</access>
							<enumeratedValues>
								<enumeratedValue>
									<name>CClk</name>
									<description>Core Clock</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>GPIOA_0</name>
									<description>GPIO A, PIN 0</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>GPIOA_1</name>
									<description>GPIO A, PIN 1</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>GPIOA_2</name>
									<description>GPIO A, PIN 2</description>
									<value>3</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>GPIOA_3</name>
									<description>GPIO A, PIN 3</description>
									<value>4</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>GPIOA_4</name>
									<description>GPIO A, PIN 4</description>
									<value>5</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>GPIOA_5</name>
									<description>GPIO A, PIN 5</description>
									<value>6</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>GPIOA_6</name>
									<description>GPIO A, PIN 6</description>
									<value>7</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>GPIOA_7</name>
									<description>GPIO A, PIN 7</description>
									<value>8</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>GPIOB_0</name>
									<description>GPIO B, PIN 0</description>
									<value>9</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>GPIOB_1</name>
									<description>GPIO B, PIN 1</description>
									<value>10</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>GPIOB_2</name>
									<description>GPIO B, PIN 2</description>
									<value>11</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>GPIOB_3</name>
									<description>GPIO B, PIN 3</description>
									<value>12</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>GPIOC_0</name>
									<description>GPIO C, PIN 0</description>
									<value>13</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>GPIOC_5</name>
									<description>GPIO C, PIN 1</description>
									<value>14</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>GPIOC_6</name>
									<description>GPIO C, PIN 2</description>
									<value>15</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<dim>8</dim>
							<dimIncrement>2</dimIncrement>
							<name>Field%sArray</name>
							<description>Array of bitfields</description>
							<bitRange>[17:16]</bitRange>
							<access>read-write</access>
							<enumeratedValues>
								<enumeratedValue>
									<name>RISING</name>
									<description>Only rising edges result in a counter increment or decrement</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>FALLING</name>
									<description>Only falling edges result in a counter increment or decrement</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>BOTH</name>
									<description>Rising and falling edges result in a counter increment or decrement</description>
									<value>2</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>SR</name>
					<description>Status Register</description>
					<addressOffset>0x04</addressOffset>
					<size>16</size>
					<access>read-only</access>
					<resetValue>0x00000000</resetValue>
					<resetMask>0xD701</resetMask>
					<fields>
						<!-- RUN: Shows if Timer is running -->
						<field>
							<name>RUN</name>
							<description>Shows if Timer is running or not</description>
							<bitRange>[0:0]</bitRange>
							<access>read-only</access>
							<enumeratedValues>
								<enumeratedValue>
									<name>Stopped</name>
									<description>Timer is not running</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>Running</name>
									<description>Timer is running</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<!-- MATCH: Shows if a Match was hit -->
						<field>
							<name>MATCH</name>
							<description>Shows if the MATCH was hit</description>
							<bitRange>[8:8]</bitRange>
							<access>read-write</access>
							<enumeratedValues>
								<enumeratedValue>
									<name>No_Match</name>
									<description>The MATCH condition was not hit</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>Match_Hit</name>
									<description>The MATCH condition was hit</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<!-- UN: Shows if an underflow occured -->
						<field>
							<name>UN</name>
							<description>Shows if an underflow occured. This flag is sticky</description>
							<bitRange>[9:9]</bitRange>
							<access>read-write</access>
							<enumeratedValues>
								<enumeratedValue>
									<name>No_Underflow</name>
									<description>No underflow occured since last clear</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>Underflow</name>
									<description>A minimum of one underflow occured since last clear</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<!-- OV: Shows if an overflow occured -->
						<field>
							<name>OV</name>
							<description>Shows if an overflow occured. This flag is sticky</description>
							<bitRange>[10:10]</bitRange>
							<access>read-write</access>
							<enumeratedValues>
								<enumeratedValue>
									<name>No_Overflow</name>
									<description>No overflow occured since last clear</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>Overflow_occured</name>
									<description>A minimum of one overflow occured since last clear</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<!-- RST: Shows if Timer is in RESET state -->
						<field>
							<name>RST</name>
							<description>Shows if Timer is in RESET state</description>
							<bitRange>[12:12]</bitRange>
							<access>read-only</access>
							<enumeratedValues>
								<enumeratedValue>
									<name>Ready</name>
									<description>Timer is not in RESET state and can operate</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>In_Reset</name>
									<description>Timer is in RESET state and can not operate</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<!-- RELOAD: Shows the currently active Reload Register -->
						<field>
							<name>RELOAD</name>
							<description>Shows the currently active RELOAD Register</description>
							<bitRange>[15:14]</bitRange>
							<access>read-only</access>
							<enumeratedValues>
								<enumeratedValue>
									<name>RELOAD0</name>
									<description>Reload Register number 0 is active</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RELOAD1</name>
									<description>Reload Register number 1 is active</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RELOAD2</name>
									<description>Reload Register number 2 is active</description>
									<value>2</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>RELOAD3</name>
									<description>Reload Register number 3 is active</description>
									<value>3</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>INT</name>
					<description>Interrupt Register</description>
					<addressOffset>0x10</addressOffset>
					<size>16</size>
					<access>write-only</access>
					<resetValue>0x00000000</resetValue>
					<resetMask>0x0771</resetMask>
					<fields>
						<!-- EN: Interrupt Enable -->
						<field>
							<name>EN</name>
							<description>Interrupt Enable</description>
							<bitRange>[0:0]</bitRange>
							<access>read-write</access>
							<enumeratedValues>
								<enumeratedValue>
									<name>Disabled</name>
									<description>Timer does not generate Interrupts</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>Enable</name>
									<description>Timer triggers the TIMERn Interrupt</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<!-- MODE: Interrupt Mode -->
						<field>
							<name>MODE</name>
							<description>Interrupt Mode, selects on which condition the Timer should generate an Interrupt</description>
							<bitRange>[6:4]</bitRange>
							<access>read-write</access>
							<enumeratedValues>
								<enumeratedValue>
									<name>Match</name>
									<description>Timer generates an Interrupt when the MATCH condition is hit</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>Underflow</name>
									<description>Timer generates an Interrupt when it underflows</description>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>Overflow</name>
									<description>Timer generates an Interrupt when it overflows</description>
									<value>2</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>NOBITFIELD_REG</name>
					<description>The Counter Register reflects the actual Value of the Timer/Counter</description>
					<addressOffset>0x20</addressOffset>
					<access>read-write</access>
					<resetValue>0x00000000</resetValue>
					<resetMask>0xFFFFFFFF</resetMask>
				</register>
				<register>
					<name>MATCH</name>
					<description>The Match Register stores the compare Value for the MATCH condition</description>
					<addressOffset>0x24</addressOffset>
					<access>read-writeOnce</access>
				</register>
				<register>
					<name>PRESCALE_RD</name>
					<description>The Prescale Register stores the Value for the prescaler. The cont event gets divided by this value</description>
					<addressOffset>0x28</addressOffset>
					<access>read-only</access>
				</register>
				<register>
					<name>PRESCALE_WR</name>
					<description>The Prescale Register stores the Value for the prescaler. The cont event gets divided by this value</description>
					<addressOffset>0x2C</addressOffset>
					<access>write-only</access>
					<resetValue>0x00000000</resetValue>
					<resetMask>0xFFFFFFFF</resetMask>
				</register>
				<register>
					<dim>4</dim>
					<dimIncrement>4</dimIncrement>
					<name>ARRAYREG[%s]</name>
					<description>Array of register</description>
					<addressOffset>0x50</addressOffset>
					<access>read-write</access>
					<resetValue>0x00000000</resetValue>
					<resetMask>0xFFFFFFFF</resetMask>
				</register>
				<register>
					<name>BITFIELD_REG</name>
					<description>Another defintion register using alternate group</description>
					<alternateGroup>alt_group</alternateGroup>
					<addressOffset>0x00</addressOffset>
				</register>
				<register>
					<name>register64bit</name>
					<description>64 bit register</description>
					<addressOffset>0x60</addressOffset>
					<size>64</size>
					<access>read-write</access>
					<resetValue>0xFFFFFFFFFFFFFFFF</resetValue>
					<resetMask>0xFFFFFFFFFFFFFFFF</resetMask>
					<fields>
						<field>
							<name>boolean</name>
							<lsb>0</lsb>
							<msb>0</msb>
							<access>read-write</access>
							<enumeratedValues>
								<enumeratedValue>
									<name>True</name>
									<value>1</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>False</name>
									<value>0</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>TIMER</name>
					<description>Register to test when peripheral has same name as register</description>
					<addressOffset>0x2000</addressOffset>
					<access>read-write</access>
				</register>
				<cluster>
					<name>Cluster1</name>
					<description>Test Cluster</description>
					<addressOffset>0x100</addressOffset>
					<cluster>
						<name>Cluster1</name>
						<description>A cluster inside another cluster</description>
						<addressOffset>0x100</addressOffset>
						<register>
							<name>NestedReg</name>
							<addressOffset>0x00</addressOffset>
							<access>read-write</access>
							<resetValue>0x12345</resetValue>
						</register>
					</cluster>
					<register>
						<name>CR</name>
						<addressOffset>0x00</addressOffset>
						<access>read-write</access>
						<resetValue>0x0</resetValue>
						<fields>
							<field>
								<name>filed1</name>
								<lsb>0</lsb>
								<msb>2</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>PSC</name>
								<lsb>3</lsb>
								<msb>4</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>val1</name>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
				</cluster>
				<cluster>
					<dim>4</dim>
					<dimIncrement>0x100</dimIncrement>
					<name>ClusterDim[%s]</name>
					<description>Test Cluster array </description>
					<addressOffset>0x200</addressOffset>
					<register>
						<name>CR</name>
						<addressOffset>0x00</addressOffset>
						<access>read-write</access>
						<resetValue>0x1000</resetValue>
						<fields>
							<field>
								<name>filed1</name>
								<lsb>0</lsb>
								<msb>2</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>PSC</name>
								<lsb>3</lsb>
								<msb>4</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>val1</name>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
				</cluster>
			</registers>
		</peripheral>
		<!-- Timer 1 -->
		<!-- Timer 2 -->
		<peripheral>
			<dim>3</dim>
			<dimIncrement>0x1000</dimIncrement>
			<name>UART[%s]</name>
			<version>1.0</version>
			<description>Test cluster</description>
			<baseAddress>0x50000000</baseAddress>
			<access>read-write</access>
			<addressBlock>
				<offset>0</offset>
				<size>0x1000000</size>
				<usage>registers</usage>
			</addressBlock>
			<interrupt>
				<name>UartInt</name>
				<description>Uart interrupt</description>
				<value>2</value>
			</interrupt>
			<registers>
				<register>
					<dim>2</dim>
					<dimIncrement>0x4</dimIncrement>
					<name>Reg1_[%s]</name>
					<description>read-write reg</description>
					<addressOffset>0x0</addressOffset>
					<access>read-write</access>
					<resetValue>0x000</resetValue>
					<resetMask>0xFFFFFFFF</resetMask>
				</register>
				<register>
					<name>RegBitfieldRaw</name>
					<description>Register with bitfields without enumeration</description>
					<addressOffset>0x100</addressOffset>
					<access>read-write</access>
					<resetValue>0x000</resetValue>
					<resetMask>0xFFFFFFFF</resetMask>
					<fields>
						<field>
							<name>Bitfield9bits</name>
							<lsb>0</lsb>
							<msb>8</msb>
							<access>read-write</access>
						</field>
						<field>
							<name>Bitfield17bits</name>
							<lsb>9</lsb>
							<msb>26</msb>
							<access>read-write</access>
						</field>
						<field>
							<name>Bool</name>
							<lsb>27</lsb>
							<msb>27</msb>
							<access>read-write</access>
						</field>
					</fields>
				</register>
				<register>
					<name>Reg16bitEnum</name>
					<description>read write reg enum</description>
					<addressOffset>0x104</addressOffset>
					<size>16</size>
					<access>read-write</access>
					<resetValue>0x000</resetValue>
					<resetMask>0xFFFF</resetMask>
					<fields>
						<field>
							<name>Bitfield9bitsEnum</name>
							<description>Check when bitfield size is not standard</description>
							<lsb>0</lsb>
							<msb>8</msb>
							<access>read-write</access>
							<enumeratedValues>
								<enumeratedValue>
									<name>Val0</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>Val256</name>
									<value>256</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<field>
							<name>Boolenum</name>
							<description>Boolean with enum</description>
							<lsb>9</lsb>
							<msb>15</msb>
							<access>read-write</access>
							<enumeratedValues>
								<enumeratedValue>
									<name>bool0</name>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>bool1</name>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
				<register>
					<name>Reg8bitRaw</name>
					<description>Read write whithout enum</description>
					<addressOffset>0x106</addressOffset>
					<size>8</size>
					<access>read-write</access>
					<resetValue>0x00</resetValue>
					<resetMask>0xFF</resetMask>
				</register>
				<register>
					<name>Reg16bitRaw</name>
					<description>Read write without enum</description>
					<addressOffset>0x107</addressOffset>
					<size>16</size>
					<access>read-write</access>
					<resetValue>0x0000</resetValue>
					<resetMask>0xFFFF</resetMask>
				</register>
				<register>
					<name>Reg32bitRaw</name>
					<description>Read write without enum</description>
					<addressOffset>0x109</addressOffset>
					<access>read-write</access>
					<resetValue>0x0000000</resetValue>
					<resetMask>0xFFFFFFFF</resetMask>
				</register>
				<cluster>
					<name>UART</name>
					<description>Cluster to test when peripheral has same name as register</description>
					<addressOffset>0x1000</addressOffset>
					<register>
						<name>UART</name>
						<addressOffset>0x00</addressOffset>
						<access>read-write</access>
						<fields>
							<field>
								<name>UART</name>
								<lsb>0</lsb>
								<msb>2</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
				</cluster>
			</registers>
		</peripheral>
		<!-- UART 0-->
		<!-- UART 1-->
		<!-- UART 2-->
		<peripheral>
			<name>FOO</name>
			<version>1.0</version>
			<description>Fake peripheral containing registers with names starting with non XID_Start characters that cannot be directly used as Rust identifier names.</description>
			<groupName>FOO</groupName>
			<baseAddress>0x60000000</baseAddress>
			<access>read-write</access>
			<addressBlock>
				<offset>0</offset>
				<size>0x100</size>
				<usage>registers</usage>
			</addressBlock>
			<interrupt>
				<name>INT_FOO</name>
				<description>Foo interrupt</description>
				<value>3</value>
			</interrupt>
			<registers>
				<register>
					<name>IN</name>
					<description>FOO Input Register</description>
					<addressOffset>0x0</addressOffset>
					<size>8</size>
					<access>read-write</access>
					<resetValue>0x0</resetValue>
					<resetMask>0xFF</resetMask>
					<fields>
						<field>
							<name>SELF</name>
							<description>SELF element of FOO</description>
							<bitOffset>1</bitOffset>
							<bitWidth>1</bitWidth>
							<access>read-write</access>
							<enumeratedValues>
								<enumeratedValue>
									<name>0_VALUE</name>
									<description>Input is on low level.</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>1_VALUE</name>
									<description>Input is on high level.</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
			</registers>
		</peripheral>
		<peripheral>
			<name>EscapeTest</name>
			<version>1.0</version>
			<description>Fake peripheral containing register with characters that may need to be escaped (and some UTF-8) when documentation is inserted.</description>
			<baseAddress>0x70000000</baseAddress>
			<access>read-write</access>
			<addressBlock>
				<offset>0</offset>
				<size>0x100</size>
				<usage>registers</usage>
			</addressBlock>
			<interrupt>
				<name>interrupt</name>
				<description>[]\&#34;😀"\n\a
						multi-line
						\r'𒀀𒀽</description>
				<value>42</value>
			</interrupt>
			<registers>
				<register>
					<name>register</name>
					<description>[]\&#34;😀"\n\a\r'𒀀𒀽</description>
					<addressOffset>0x0</addressOffset>
					<size>8</size>
					<access>read-write</access>
					<resetValue>0x0</resetValue>
					<resetMask>0xFF</resetMask>
					<fields>
						<field>
							<name>field</name>
							<description>[]\&#34;😀"\n\a\r'𒀀𒀽</description>
							<bitOffset>1</bitOffset>
							<bitWidth>1</bitWidth>
							<access>read-write</access>
							<enumeratedValues>
								<enumeratedValue>
									<name>enum_value</name>
									<description>[]\&#34;😀"\n\a\r'𒀀𒀽</description>
									<value>0</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
					</fields>
				</register>
			</registers>
		</peripheral>
		<peripheral>
			<name>DerivedTest</name>
			<version>1.0</version>
			<description>Fake Peripheral to test cluster and register with derivedFrom attribute</description>
			<baseAddress>0xA0000</baseAddress>
			<access>read-write</access>
			<addressBlock>
				<offset>0</offset>
				<size>0x2000</size>
				<usage>registers</usage>
			</addressBlock>
			<registers>
				<register>
					<name>BaseRegister</name>
					<description>BaseRegister</description>
					<addressOffset>0x1000</addressOffset>
					<size>16</size>
					<access>read-write</access>
					<resetValue>0x00000000</resetValue>
					<resetMask>0xD701</resetMask>
					<fields>
						<!-- RUN: Shows if Timer is running -->
						<field>
							<name>RUN</name>
							<description>Shows if Timer is running or not</description>
							<bitRange>[0:0]</bitRange>
							<access>read-only</access>
							<enumeratedValues>
								<enumeratedValue>
									<name>Stopped</name>
									<description>Timer is not running</description>
									<value>0</value>
								</enumeratedValue>
								<enumeratedValue>
									<name>Running</name>
									<description>Timer is running</description>
									<value>1</value>
								</enumeratedValue>
							</enumeratedValues>
						</field>
						<!-- MATCH: Shows if a Match was hit -->
					</fields>
				</register>
				<register derivedFrom="BaseRegister">
					<name>DerivedRegister</name>
					<addressOffset>0x1002</addressOffset>
				</register>
				<register derivedFrom="TIMER.Cluster1.CR">
					<name>DerivedFromFarAway</name>
					<addressOffset>0x1004</addressOffset>
				</register>
				<cluster>
					<name>BaseCluster</name>
					<description>Cluster that defines the base type</description>
					<headerStructName>BaseClusterType</headerStructName>
					<addressOffset>0x0</addressOffset>
					<register>
						<name>Reg1</name>
						<addressOffset>0x00</addressOffset>
					</register>
					<register>
						<name>Reg2</name>
						<addressOffset>0x4</addressOffset>
					</register>
				</cluster>
				<cluster derivedFrom="BaseCluster">
					<dim>4</dim>
					<dimIncrement>8</dimIncrement>
					<name>ArrayCluster[%s]</name>
					<description>ArrayCluster</description>
					<addressOffset>0x8</addressOffset>
				</cluster>
				<cluster derivedFrom="ArrayCluster0">
					<dim>1</dim>
					<dimIncrement>16</dimIncrement>
					<name>DerivedDerivedCluster[%s]</name>
					<description/>
					<addressOffset>0x100</addressOffset>
				</cluster>
				<cluster derivedFrom="TIMER.Cluster1.Cluster1">
					<name>DerivedFromFarAwayCluster</name>
					<description/>
					<addressOffset>0x200</addressOffset>
				</cluster>
			</registers>
		</peripheral>
		<peripheral>
			<name>P33</name>
			<description>Port naming peripheral struct and peripheral const are the same</description>
			<baseAddress>0x70100000</baseAddress>
			<access>read-write</access>
			<addressBlock>
				<offset>0</offset>
				<size>0x2000</size>
				<usage>registers</usage>
			</addressBlock>
			<registers>
				<cluster>
					<name>I2C2</name>
					<description>Cluster that defines the base type</description>
					<headerStructName/>
					<addressOffset>0x0</addressOffset>
					<register>
						<name>Reg1</name>
						<addressOffset>0x00</addressOffset>
					</register>
					<register>
						<name>Reg2</name>
						<addressOffset>0x4</addressOffset>
					</register>
				</cluster>
			</registers>
		</peripheral>
		<peripheral derivedFrom="P33">
			<name>DerivedPeripheral</name>
			<description>DerivedPeripheral</description>
			<baseAddress>0x70200000</baseAddress>
		</peripheral>
	</peripherals>
	<vendorExtensions>
		<aurixCSFR>
			<peripheral>
				<name>CPU0</name>
				<version>100</version>
				<description>CPU</description>
				<baseAddress>0</baseAddress>
				<addressBlock>
					<offset>0</offset>
					<size>65472</size>
					<usage>registers</usage>
				</addressBlock>
				<registers>
					<cluster>
						<dim>18</dim>
						<dimIncrement>8</dimIncrement>
						<name>DPR[%s]</name>
						<description>DPR</description>
						<addressOffset>49152</addressOffset>
						<register>
							<name>DPRy_L</name>
							<description>CPUx Data Protection Range 0  Lower Bound Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>0</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>LOWBND</name>
									<description>DPRy Lower Boundary Address   LOWBND</description>
									<lsb>3</lsb>
									<msb>31</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
						<register>
							<name>DPRy_U</name>
							<description>CPUx Data Protection Range 0  Upper Bound Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>4</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>UPPBND</name>
									<description>DPRy Upper Boundary Address   UPPBND</description>
									<lsb>3</lsb>
									<msb>31</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
					</cluster>
					<cluster>
						<dim>10</dim>
						<dimIncrement>8</dimIncrement>
						<name>CPR[%s]</name>
						<description>CPR</description>
						<addressOffset>53248</addressOffset>
						<register>
							<name>CPRy_L</name>
							<description>CPUx Code Protection Range 0 Lower Bound Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>0</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>LOWBND</name>
									<description>CPRy Lower Boundary Address   LOWBND</description>
									<lsb>5</lsb>
									<msb>31</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
						<register>
							<name>CPRy_U</name>
							<description>CPUx Code Protection Range 0 Upper Bound Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>4</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>UPPBND</name>
									<description>CPR0 m Upper Boundary Address   UPPBND</description>
									<lsb>5</lsb>
									<msb>31</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
					</cluster>
					<cluster>
						<name>TPS</name>
						<description>TPS</description>
						<addressOffset>58368</addressOffset>
						<register>
							<name>CON</name>
							<description>CPUx Temporal Protection System Control Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>0</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>TEXP0</name>
									<description>Timer0 Expired Flag   TEXP0. Set when the corresponding timer expires. Cleared on any write to the  TIMER0 register.</description>
									<lsb>0</lsb>
									<msb>0</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>TEXP1</name>
									<description>Timer1 Expired Flag   TEXP1. Set when the corresponding timer expires. Cleared on any write to the  TIMER1 register.</description>
									<lsb>1</lsb>
									<msb>1</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>TEXP2</name>
									<description>Timer1 Expired Flag   TEXP2. Set when the corresponding timer expires. Cleared on any write to the  TIMER1 register.</description>
									<lsb>2</lsb>
									<msb>2</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>TTRAP</name>
									<description>Temporal Protection Trap   TTRAP. If set  indicates that a TAE trap has been requested. Any subsequent TAE traps are disabled. A write clears the flag and re enables TAE traps.</description>
									<lsb>16</lsb>
									<msb>16</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
						<register>
							<dim>3</dim>
							<dimIncrement>4</dimIncrement>
							<name>TIMER[%s]</name>
							<description>CPUx Temporal Protection System Timer Register 0
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>4</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>Timer</name>
									<description>Temporal Protection Timer   Timer. Writing zero de activates the Timer. Writing a non zero value starts the Timer. Any write clears the corresponding TPS CON.TEXP flag. Read returns the current Timer value.</description>
									<lsb>0</lsb>
									<msb>31</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
					</cluster>
					<cluster>
						<name>TPS_EXTIM</name>
						<description>TPS EXTIM</description>
						<addressOffset>58432</addressOffset>
						<register>
							<name>ENTRY_LVAL</name>
							<description>CPUx Exception Entry Timer Load Value
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>0</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>ENTRY_LVAL</name>
									<description>Exception Entry Timer Load value   ENTRY LVAL. Value loaded into the exception entry timer on detection of an enabled exception. Bits  3 0  are constrained to be 0</description>
									<lsb>4</lsb>
									<msb>11</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
						<register>
							<name>ENTRY_CVAL</name>
							<description>CPUx Exception Entry Timer Current Value
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>4</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>ENTRY_CVAL</name>
									<description>Exception Entry Timer Current Value   ENTRY CVAL. Current value of the exception entry timer.</description>
									<lsb>0</lsb>
									<msb>11</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
						<register>
							<name>EXIT_LVAL</name>
							<description>CPUx Exception Exit  Timer Load Value
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>8</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>EXIT_LVAL</name>
									<description>Exception Exit Timer Load value   EXIT LVAL. Value loaded into the exception exit timer on detection of an enabled exception. Bits  3 0  are constrained to be 0</description>
									<lsb>4</lsb>
									<msb>23</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
						<register>
							<name>EXIT_CVAL</name>
							<description>CPUx Exception Exit Timer Current Value
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>12</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>EXIT_CVAL</name>
									<description>Exception Exit Timer Current Value   EXIT CVAL. Current value of the exception exit timer.</description>
									<lsb>0</lsb>
									<msb>23</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
						<register>
							<name>CLASS_EN</name>
							<description>CPUx Exception Timer Class Enable Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>16</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>EXTIM_CLASS_EN</name>
									<description>Exception Timer Class Enables   EXTIM CLASS EN. Trap Class enables for exception timer.</description>
									<lsb>0</lsb>
									<msb>7</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
						<register>
							<name>STAT</name>
							<description>CPUx Exception Timer Status Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>20</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>EXIT_TIN</name>
									<description>Exception Exit Timer TIN   EXIT TIN. Exception Exit Timer TIN of triggering trap.</description>
									<lsb>0</lsb>
									<msb>7</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>EXIT_CLASS</name>
									<description>Exception Exit Timer Class   EXIT CLASS. Exception exit Timer Class of triggering trap.</description>
									<lsb>8</lsb>
									<msb>10</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>EXIT_AT</name>
									<description>Exception Exit Timer Alarm Triggered   EXIT AT. Exception Exit Timer Alarm triggered sticky bit. Alarm triggered since last cleared.</description>
									<lsb>15</lsb>
									<msb>15</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>ENTRY_TIN</name>
									<description>Exception Entry Timer TIN   ENTRY TIN. Exception Entry Timer TIN of triggering trap.</description>
									<lsb>16</lsb>
									<msb>23</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>ENTRY_CLASS</name>
									<description>Exception Entry Timer Class   ENTRY CLASS. Exception Entry Timer Class of triggering trap.</description>
									<lsb>24</lsb>
									<msb>26</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>ENTRY_AT</name>
									<description>Exception Entry Timer Alarm Triggered   ENTRY AT. Exception Entry Timer Alarm triggered sticky bit. Alarm triggered since last cleared.</description>
									<lsb>31</lsb>
									<msb>31</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
						<register>
							<name>FCX</name>
							<description>CPUx Exception Timer FCX Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>24</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>EXIT_FCX</name>
									<description>Exception Exit Timer FCX   EXIT FCX. Exception Exit Timer FCX of triggering trap.</description>
									<lsb>0</lsb>
									<msb>19</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
					</cluster>
					<cluster>
						<name>FPU_TRAP</name>
						<description>FPU TRAP</description>
						<addressOffset>40960</addressOffset>
						<register>
							<name>CON</name>
							<description>CPUx Trap Control Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>0</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>TST</name>
									<description>Trap Status   TST</description>
									<lsb>0</lsb>
									<msb>0</msb>
									<access>read-only</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 No instruction captured.  The next enabled exception will cause the exceptional instruction to be captured.</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>1 Instruction captured. No further enabled exceptions will be captured until TST is cleared.</description>
											<value>1</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>TCL</name>
									<description>Trap Clear   TCL. Read  always reads as 0.</description>
									<lsb>1</lsb>
									<msb>1</msb>
									<access>write-only</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 No effect.</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>1 Clears the trapped instruction  TST will be negated .</description>
											<value>1</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>RM</name>
									<description>Captured Rounding Mode   RM. The rounding mode of the captured instruction. Only valid when TST is asserted. Note that this is the rounding mode supplied to the FPU for the exceptional instruction. UPDFL instructions may cause a trap and change the rounding mode. In this case the RM bits capture the input rounding mode</description>
									<lsb>8</lsb>
									<msb>9</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>FXE</name>
									<description>FX Trap Enable   FXE. When set  an instruction generating an FX exception will trigger a trap.</description>
									<lsb>18</lsb>
									<msb>18</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>FUE</name>
									<description>FU Trap Enable   FUE. When set  an instruction generating an FU exception will trigger a trap.</description>
									<lsb>19</lsb>
									<msb>19</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>FZE</name>
									<description>FZ Trap Enable   FZE. When set  an instruction generating an FZ exception will trigger a trap.</description>
									<lsb>20</lsb>
									<msb>20</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>FVE</name>
									<description>FV Trap Enable   FVE. When set  an instruction generating an FV exception will trigger a trap.</description>
									<lsb>21</lsb>
									<msb>21</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>FIE</name>
									<description>FI Trap Enable   FIE. When set  an instruction generating an FI exception will trigger a trap.</description>
									<lsb>22</lsb>
									<msb>22</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>FX</name>
									<description>Captured FX   FX. Asserted if the captured instruction asserted FX. Only valid when TST is asserted.</description>
									<lsb>26</lsb>
									<msb>26</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>FU</name>
									<description>Captured FU   FU. Asserted if the captured instruction asserted FU. Only valid when TST is asserted.</description>
									<lsb>27</lsb>
									<msb>27</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>FZ</name>
									<description>Captured FZ   FZ. Asserted if the captured instruction asserted FZ. Only valid when TST is asserted</description>
									<lsb>28</lsb>
									<msb>28</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>FV</name>
									<description>Captured FV   FV. Asserted if the captured instruction asserted FV. Only valid when TST is asserted</description>
									<lsb>29</lsb>
									<msb>29</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>FI</name>
									<description>Captured FI   FI. Asserted if the captured instruction asserted FI. Only valid when TST is asserted</description>
									<lsb>30</lsb>
									<msb>30</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
						<register>
							<name>PC</name>
							<description>CPUx Trapping Instruction Program Counter Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>4</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>PC</name>
									<description>Captured Program Counter   PC. The program counter  virtual address  of the captured instruction. Only valid when FPU TRAP CON.TST is asserted.</description>
									<lsb>0</lsb>
									<msb>31</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
						<register>
							<name>OPC</name>
							<description>CPUx Trapping Instruction Opcode Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>8</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>OPC</name>
									<description>Captured Opcode   OPC. The secondary opcode of the captured instruction. When FPU TRAP OPC.FMT 0 only bits  3 0  are defined. OPC is valid only when FPU TRAP CON.TST is asserted.</description>
									<lsb>0</lsb>
									<msb>7</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>FMT</name>
									<description>Captured Instruction Format   FMT. The format of the captured instruction s opcode. Only valid when FPU TRAP CON.TST is asserted.</description>
									<lsb>8</lsb>
									<msb>8</msb>
									<access>read-only</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 RRR</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>1 RR</description>
											<value>1</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>DREG</name>
									<description>Captured Destination Register   DREG. The destination register of the captured instruction. ... Only valid when FPU TRAP CON.TST is asserted.</description>
									<lsb>16</lsb>
									<msb>19</msb>
									<access>read-only</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 Data general purpose register 0.</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_1515</name>
											<description>F Data general purpose register 15.</description>
											<value>15</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
							</fields>
						</register>
						<register>
							<name>SRC1</name>
							<description>CPUx Trapping Instruction Operand Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>16</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>SRC1</name>
									<description>Captured SRC1 Operand   SRC1. The SRC1 operand of the captured instruction. Only valid when FPU TRAP CON.TST is asserted.</description>
									<lsb>0</lsb>
									<msb>31</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
						<register>
							<name>SRC2</name>
							<description>CPUx Trapping Instruction Operand Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>20</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>SRC2</name>
									<description>Captured SRC2 Operand   SRC2. The SRC2 operand of the captured instruction. Only valid when FPU TRAP CON.TST is asserted.</description>
									<lsb>0</lsb>
									<msb>31</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
						<register>
							<name>SRC3</name>
							<description>CPUx Trapping Instruction Operand Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>24</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>SRC3</name>
									<description>Captured SRC3 Operand   SRC3. The SRC3 operand of the captured instruction. Only valid when FPU TRAP CON.TST is asserted.</description>
									<lsb>0</lsb>
									<msb>31</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
					</cluster>
					<cluster>
						<dim>8</dim>
						<dimIncrement>8</dimIncrement>
						<name>TR[%s]</name>
						<description>Trigger</description>
						<addressOffset>61440</addressOffset>
						<register>
							<name>TRiEVT</name>
							<description>CPUx Trigger Event 0
 resetvalue={Debug Reset:0x0}</description>
							<addressOffset>0</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>EVTA</name>
									<description>Event Associated   EVTA. Specifies the Debug Action associated with the Debug Event </description>
									<lsb>0</lsb>
									<msb>2</msb>
									<access>read-write</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>000 BOD 0  Disabled. BOD 1  Disabled.</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>001 BOD 0  Pulse BRKOUT Signal. BOD 1  None.</description>
											<value>1</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_22</name>
											<description>010 BOD 0  Halt and pulse BRKOUT Signal. BOD 1  Halt.</description>
											<value>2</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_33</name>
											<description>011 BOD 0  Breakpoint trap and pulse BRKOUT Signal. BOD 1  Breakpoint trap.</description>
											<value>3</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_44</name>
											<description>100 BOD 0  Breakpoint interrupt 0 and pulse BRKOUT Signal. BOD 1  Breakpoint interrupt 0.</description>
											<value>4</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_55</name>
											<description>101 BOD 0  If implemented  breakpoint interrupt 1 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 1. If not implemented  None.</description>
											<value>5</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_66</name>
											<description>110 BOD 0  If implemented  breakpoint interrupt 2 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 2. If not implemented  None.</description>
											<value>6</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_77</name>
											<description>111 BOD 0  If implemented  breakpoint interrupt 3 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 3. If not implemented  None.</description>
											<value>7</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>BBM</name>
									<description>Break Before Make  BBM  or Break After Make  BAM  Selection   BBM. Code triggers BBM or BAM selection. Data access and data code combination access triggers can only create BAM Debug Events. When these triggers occur  TRnEVT.BBM is ignored.</description>
									<lsb>3</lsb>
									<msb>3</msb>
									<access>read-write</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 Code only triggers Break After Make  BAM .</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>1 Code only triggers Break Before Make  BBM .</description>
											<value>1</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>BOD</name>
									<description>Breakout Disable   BOD</description>
									<lsb>4</lsb>
									<msb>4</msb>
									<access>read-write</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 BRKOUT signal asserted according to the action specified in the EVTA field.</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>1 BRKOUT signal not asserted. This takes priority over any assertion generated by the EVTA field.</description>
											<value>1</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>SUSP</name>
									<description>CDC Suspend Out Signal State   SUSP. Value to be assigned to the CDC suspend out signal when the Debug Event is raised.</description>
									<lsb>5</lsb>
									<msb>5</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>CNT</name>
									<description>Counter   CNT. When this event occurs adjust the control of the performance counters in task mode as follows </description>
									<lsb>6</lsb>
									<msb>7</msb>
									<access>read-write</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>00 No change.</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>01 Start the performance counters.</description>
											<value>1</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_22</name>
											<description>10 Stop the performance counters.</description>
											<value>2</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_33</name>
											<description>11 Toggle the performance counter control  i.e. start it if it is currently stopped  stop it if it is currently running .</description>
											<value>3</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>TYP</name>
									<description>Input Selection   TYP</description>
									<lsb>12</lsb>
									<msb>12</msb>
									<access>read-write</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 Address</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>1 PC</description>
											<value>1</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>RNG</name>
									<description>Compare Type   RNG. Once an even numbered comparator has been set to range  the EVTR settings of its associated upper neighbour will be ignored.</description>
									<lsb>13</lsb>
									<msb>13</msb>
									<access>read-write</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_11</name>
											<description>1 Range</description>
											<value>1</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 Equality</description>
											<value>0</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>ASI_EN</name>
									<description>Enable ASI Comparison   ASI EN</description>
									<lsb>15</lsb>
									<msb>15</msb>
									<access>read-write</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 No ASI comparison performed. Debug Trigger is valid for all processes.</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>1 Enable ASI comparison. Debug Events are only triggered when the current process ASI matches TRnEVT.ASI.</description>
											<value>1</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>ASI</name>
									<description>Address Space Identifier   ASI. The ASI of the Debug Trigger process.</description>
									<lsb>16</lsb>
									<msb>20</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>AST</name>
									<description>Address Store   AST. Used in conjunction with TYP 0</description>
									<lsb>27</lsb>
									<msb>27</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>ALD</name>
									<description>Address Load   ALD. Used in conjunction with TYP 0</description>
									<lsb>28</lsb>
									<msb>28</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
						<register>
							<name>TRiADR</name>
							<description>CPUx Trigger Address 0
 resetvalue={Debug Reset:0x0}</description>
							<addressOffset>4</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>ADDR</name>
									<description>Comparison Address   ADDR. For PC comparison  bit 0  is always zero.</description>
									<lsb>0</lsb>
									<msb>31</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
					</cluster>
					<register>
						<name>SMACON</name>
						<description>CPUx SIST Mode Access Control Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>36876</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>IODT</name>
								<description>In Order Data Transactions   IODT</description>
								<lsb>24</lsb>
								<msb>24</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Normal operation  Non dependent loads bypass stores.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 In order operation  Loads always flush preceding stores  processor store buffer disabled.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DIEAR</name>
						<description>CPUx Data Integrity Error Address Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>36896</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>TA</name>
								<description>Transaction Address   TA. Physical address being accessed by operation that encountered data integrity error.</description>
								<lsb>0</lsb>
								<msb>31</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DIETR</name>
						<description>CPUx Data Integrity Error Trap Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>36900</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>IED</name>
								<description>Integrity Error Detected   IED</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Write  Clear IED bit  re enable DIETR and DIEAR update. Read   No data integrity error condition occurred</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Write   No Effect. Read  Data integrity error condition detected. DIETR and DIEAR contents valid  further DIETR and DIEAR updates disabled..</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>IE_T</name>
								<description>Integrity Error   Tag Memory   IE T</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_C</name>
								<description>Integrity Error   Cache Memory   IE C</description>
								<lsb>2</lsb>
								<msb>2</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_S</name>
								<description>Integrity Error   Scratchpad Memory   IE S</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_BI</name>
								<description>Integrity Error   Bus Interface   IE BI</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>E_INFO</name>
								<description>Error Information   E INFO. If IE BS   1  Bus Master Tag ID of requesting masterIf IE C   1  Cache way.</description>
								<lsb>5</lsb>
								<msb>10</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_UNC</name>
								<description>Dual Bit Error Detected   IE UNC</description>
								<lsb>11</lsb>
								<msb>11</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_SP</name>
								<description>Safety Protection Error Detected   IE SP</description>
								<lsb>12</lsb>
								<msb>12</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_BS</name>
								<description>Bus Slave Access Indicator   IE BS</description>
								<lsb>13</lsb>
								<msb>13</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_DLMU</name>
								<description>Integrity Error   DLMU   IE DLMU</description>
								<lsb>14</lsb>
								<msb>14</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_LPB</name>
								<description>Integrity Error   Local Pflash Bank   IE LPB</description>
								<lsb>15</lsb>
								<msb>15</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_MTMV</name>
								<description>Memory Test Mode Violation detected   IE MTMV</description>
								<lsb>16</lsb>
								<msb>16</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PIEAR</name>
						<description>CPUx Program Integrity Error Address Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>37392</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>TA</name>
								<description>Transaction Address   TA. Physical address being accessed by operation that encountered program integrity error.</description>
								<lsb>0</lsb>
								<msb>31</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PIETR</name>
						<description>CPUx Program Integrity Error Trap Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>37396</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>IED</name>
								<description>Integrity Error Detected   IED</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Write  Clear IED bit  re enable PIETR and PIEAR update. Read   No data integrity error condition occurred</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Write   No Effect. Read  Data integrity error condition detected. PIETR and PIEAR contents valid  further PIETR and PIEAR updates disabled..</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>IE_T</name>
								<description>Integrity Error   TAG Memory   IE T</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_C</name>
								<description>Integrity Error   Cache Memory   IE C</description>
								<lsb>2</lsb>
								<msb>2</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_S</name>
								<description>Integrity Error   Scratchpad Memory   IE S</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_BI</name>
								<description>Integrity Error   Bus Interface   IE BI</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>E_INFO</name>
								<description>Error Information   E INFO. If IE BS  1  Bus Master Tag ID of requesting masterIf IE C   1  Cache way.</description>
								<lsb>5</lsb>
								<msb>10</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_UNC</name>
								<description>Integrity Error   Uncorrectable Error Detected   IE UNC</description>
								<lsb>11</lsb>
								<msb>11</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_SP</name>
								<description>Safety Protection Error Detected   IE SP</description>
								<lsb>12</lsb>
								<msb>12</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_BS</name>
								<description>Bus Slave Access Indicator   IE BS</description>
								<lsb>13</lsb>
								<msb>13</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_ADDR</name>
								<description>Address Phase error detected at SRI slave interface   IE ADDR</description>
								<lsb>14</lsb>
								<msb>14</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_LPB</name>
								<description>Integrity Error   Local Pflash bank   IE LPB</description>
								<lsb>15</lsb>
								<msb>15</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_MTMV</name>
								<description>Memory Test Mode Violation detected   IE MTMV</description>
								<lsb>16</lsb>
								<msb>16</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>TASK_ASI</name>
						<description>CPUx Task Address Space Identifier Register
 resetvalue={Application Reset:0x1F}</description>
						<addressOffset>32772</addressOffset>
						<size>32</size>
						<resetValue>31</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>ASI</name>
								<description>Address Space Identifier   ASI. The ASI register contains the Address Space Identifier of the current process.</description>
								<lsb>0</lsb>
								<msb>4</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PMA0</name>
						<description>CPUx Data Access CacheabilityRegister
 resetvalue={Application Reset:0x300}</description>
						<addressOffset>33024</addressOffset>
						<size>32</size>
						<resetValue>768</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>DAC</name>
								<description>Data Access Cacheability Segments FHto 0H   DAC.  Note   segments F H  E H  D H and A H are constrained to be        non cacheable </description>
								<lsb>0</lsb>
								<msb>15</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PMA1</name>
						<description>CPUx Code Access CacheabilityRegister
 resetvalue={Application Reset:0x300}</description>
						<addressOffset>33028</addressOffset>
						<size>32</size>
						<resetValue>768</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CAC</name>
								<description>Code Access Cacheability Segments FH 0H   CAC.  Note  Segments F H  E H  C H  A H are constrained to be non cacheable </description>
								<lsb>0</lsb>
								<msb>15</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PMA2</name>
						<description>CPUx  Peripheral Space Identifier register
 resetvalue={Application Reset:0x0C000}</description>
						<addressOffset>33032</addressOffset>
						<size>32</size>
						<resetValue>49152</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>PSI</name>
								<description>Peripheral Space Identifier Segments FH 0H   PSI</description>
								<lsb>0</lsb>
								<msb>15</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>COMPAT</name>
						<description>CPUx Compatibility Control Register
 resetvalue={Application Reset:0x0FFFFFFFF}</description>
						<addressOffset>37888</addressOffset>
						<size>32</size>
						<resetValue>4294967295</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>RM</name>
								<description>Rounding Mode Compatibility   RM</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 PSW.RM not restored by RET.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 PSW.RM restored by RET  TC1.3 behavior .</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>SP</name>
								<description>SYSCON Safety Protection Mode Compatibility   SP</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 SYSCON 31 1  safety endinit protected.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 SYSCON 31 1  not safety endinit protected  TC1.3 behavior .</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>PCXI</name>
						<description>CPUx Previous Context Information Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65024</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>PCXO</name>
								<description>Previous Context Pointer Offset Field   PCXO. The PCXO and PCXS fields form the pointer PCX  which points to the CSA of the previous context.</description>
								<lsb>0</lsb>
								<msb>15</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>PCXS</name>
								<description>Previous Context Pointer Segment Address   PCXS. Contains the segment address portion of the PCX. This field is used in conjunction with the PCXO field.</description>
								<lsb>16</lsb>
								<msb>19</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>UL</name>
								<description>Upper or Lower Context Tag   UL. Identifies the type of context saved. If the type does not match the type expected when a context restore operation is performed  a trap is generated.</description>
								<lsb>20</lsb>
								<msb>20</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Lower Context</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Upper Context</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>PIE</name>
								<description>Previous Interrupt Enable   PIE. Indicates the state of the interrupt enable bit  ICR.IE  for the interrupted task.</description>
								<lsb>21</lsb>
								<msb>21</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>PCPN</name>
								<description>Previous CPU Priority Number   PCPN. Contains the priority level number of the interrupted task.</description>
								<lsb>22</lsb>
								<msb>29</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PSW</name>
						<description>CPUx Program Status Word
 resetvalue={Application Reset:0x0B80}</description>
						<addressOffset>65028</addressOffset>
						<size>32</size>
						<resetValue>2944</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CDC</name>
								<description>Call Depth Counter   CDC. Consists of two variable width subfields. The first subfield consists of a string of zero or more initial 1 bits  terminated by the first 0 bit. The remaining bits form the second subfield  CDC.COUNT  which constitutes the Call Depth Count value. The count value is incremented on each Call and is decremented on a Return. 0cccccc B   6 bit counter  trap on overflow. 10ccccc B   5 bit counter  trap on overflow. 110cccc B   4 bit counter  trap on overflow. 1110ccc B   3 bit counter  trap on overflow. 11110cc B   2 bit counter  trap on overflow. 111110c B   1 bit counter  trap on overflow. 1111110 B   Trap every call  Call Trace mode . 1111111 B   Disable Call Depth Counting. When the call depth count  CDC.COUNT  overflows a trap  CDO  is generated. Setting the CDC to 1111110 B allows no bits for the counter and causes every call to be trapped. This is used for Call Depth Tracing. Setting the CDC to 1111111 B disables Call Depth Counting.</description>
								<lsb>0</lsb>
								<msb>6</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CDE</name>
								<description>Call Depth Count Enable   CDE. Enables call depth counting  provided that the PSW.CDC mask field is not all set to 1. If PSW.CDC   1111111 B   call depth counting is disabled regardless of the setting on the PSW.CDE bit.</description>
								<lsb>7</lsb>
								<msb>7</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Call depth counting is temporarily disabled. It is automatically re enabled after execution of the next Call instruction.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Call depth counting is enabled.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>IS</name>
								<description>Interrupt Stack Control   IS. Determines if the current execution thread is using the shared global  interrupt  stack or a user stack.</description>
								<lsb>9</lsb>
								<msb>9</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 User Stack.  If an interrupt is taken when the IS bit is 0  then the stack pointer register is loaded from the ISP register before execution starts at the first instruction of the Interrupt Service Routine  ISR .</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Shared Global Stack.  If an interrupt is taken when the PSW.IS bit is 1  then the current value of the stack pointer is used by the Interrupt Service Routine  ISR .</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>IO</name>
								<description>Access Privilege Level Control  I O Privilege    IO. Determines the access level to special function registers and peripheral devices.</description>
								<lsb>10</lsb>
								<msb>11</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>00 User 0 Mode No peripheral access. Access to memory regions with the peripheral space attribute are prohibited and results in a PSE or MPP trap. This access level is given to tasks that need not directly access peripheral devices. Tasks at this level do not have permission to enable or disable interrupts.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>01 User 1 Mode Regular peripheral access. Enables access to common peripheral devices that are not specially protected  including read write access to serial I O ports  read access to timers  and access to most I O status registers. Tasks at this level may disable interrupts.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>10 Supervisor Mode Enables access to all peripheral devices. It enables read write access to core registers and protected peripheral devices. Tasks at this level may disable interrupts.</description>
										<value>2</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>S</name>
								<description>Safe Task Identifier   S</description>
								<lsb>14</lsb>
								<msb>14</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>USB</name>
								<description>User Status Bits   USB. The eight most significant bits of the PSW are designated as User Status Bits. These bits may be set or cleared as side effects of instruction execution. Refer to the TriCore Architecture manual for details.</description>
								<lsb>24</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PC</name>
						<description>CPUx Program Counter
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65032</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>0</resetMask>
						<fields>
							<field>
								<name>PC</name>
								<description>Program Counter   PC</description>
								<lsb>1</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>SYSCON</name>
						<description>CPUx System Configuration Register
 resetvalue={Application Reset:0x0,Application Reset:0x0}</description>
						<addressOffset>65044</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>0</resetMask>
						<fields>
							<field>
								<name>FCDSF</name>
								<description>Free Context List Depleted Sticky Flag   FCDSF. This sticky bit indicates that a FCD  Free Context List Depleted  trap occurred since the bit was last cleared by software.</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 No FCD trap occurred since the last clear.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 An FCD trap occurred since the last clear.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>PROTEN</name>
								<description>Memory Protection Enable   PROTEN. Enables the memory protection system. Memory protection is controlled through the memory protection register        sets. Note  Initialize the protection register sets prior to setting        PROTEN to one.</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Memory Protection is disabled.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Memory Protection is enabled.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>TPROTEN</name>
								<description>Temporal Protection Enable   TPROTEN. Enable the Temporal Protection system.</description>
								<lsb>2</lsb>
								<msb>2</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Temporal Protection is disabled.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Temporal Protection is enabled.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>IS</name>
								<description>Initial State Interrupt   IS. of PSW.S bit in interrupt handle</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>TS</name>
								<description>Initial State Trap   TS. of PSW.S bit in trap handle</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>ESDIS</name>
								<description>Emulator Space Disable. Disable the Emulator Space system</description>
								<lsb>8</lsb>
								<msb>8</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>U1_IED</name>
								<description>User 1 Instruction execution disable   U1 IED. Disable the execution of User 1 mode instructions in User 1 IO mode. Disables User 1 ability to enable and  disable interrupts.</description>
								<lsb>16</lsb>
								<msb>16</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>U1_IOS</name>
								<description>User 1 Peripheral access as supervisor   U1 IOS. Allow User 1 mode tasks to access peripherals as if in Supervisor mode. Enables User 1 access to all  peripheral registers.</description>
								<lsb>17</lsb>
								<msb>17</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>BHALT</name>
								<description>Boot Halt   BHALT</description>
								<lsb>24</lsb>
								<msb>24</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Core is not in boot halt.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Core is in boot halt  write to 0 will exit</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CPU_ID</name>
						<description>CPUx Identification Register TC1.6.2P
 resetvalue={Application Reset:0x0C0C021}</description>
						<addressOffset>65048</addressOffset>
						<size>32</size>
						<resetValue>12632097</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>MOD_REV</name>
								<description>Revision Number   MOD REV</description>
								<lsb>0</lsb>
								<msb>7</msb>
								<access>read-only</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_3232</name>
										<description>20 Reset value</description>
										<value>32</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>MOD_32B</name>
								<description>32 Bit Module Enable   MOD 32B</description>
								<lsb>8</lsb>
								<msb>15</msb>
								<access>read-only</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_192192</name>
										<description>C0 A value of C0 H in this field indicates a 32 bit module with a 32 bit module ID register.</description>
										<value>192</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>MOD</name>
								<description>Module Identification Number   MOD</description>
								<lsb>16</lsb>
								<msb>31</msb>
								<access>read-only</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_192192</name>
										<description>00C0 For module identification.</description>
										<value>192</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CORE_ID</name>
						<description>CPUx Core Identification Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65052</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967288</resetMask>
						<fields>
							<field>
								<name>CORE_ID</name>
								<description>Core Identification Number   CORE ID. The identification number of the core.</description>
								<lsb>0</lsb>
								<msb>2</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>BIV</name>
						<description>CPUx Base Interrupt Vector Table Pointer
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65056</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>VSS</name>
								<description>Vector Spacing Select   VSS. 0  32 byte vector spacing. 1  8 Byte vector spacing.</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>BIV</name>
								<description>Base Address of Interrupt Vector Table   BIV. The address in the BIV register must be aligned to an even byte address  halfword address . Because of the simple ORing of the left shifted priority number and the contents of the BIV register  the alignment of the base address of the vector table must be to a power of two boundary  dependent on the number of interrupt entries used. For the full range of 256 interrupt entries an alignment to an 8 KByte boundary is required. If fewer sources are used  the alignment requirements are correspondingly relaxed.</description>
								<lsb>1</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>BTV</name>
						<description>CPUx Base Trap Vector Table Pointer
 resetvalue={Application Reset:0x0A0000100}</description>
						<addressOffset>65060</addressOffset>
						<size>32</size>
						<resetValue>2684354816</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>BTV</name>
								<description>Base Address of Trap Vector Table   BTV. The address in the BTV register must be aligned to an even byte address  halfword address . Also  due to the simple ORing of the left shifted trap identification number and the contents of the BTV register  the alignment of the base address of the vector table must be to a power of two boundary. There are eight different trap classes  resulting in Trap Classes from 0 to 7. The contents of BTV should therefore be set to at least a 256 byte boundary  8 Trap Classes   8 word spacing .</description>
								<lsb>1</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>ISP</name>
						<description>CPUx Interrupt Stack Pointer
 resetvalue={Application Reset:0x100}</description>
						<addressOffset>65064</addressOffset>
						<size>32</size>
						<resetValue>256</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>ISP</name>
								<description>Interrupt Stack Pointer   ISP</description>
								<lsb>0</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>ICR</name>
						<description>CPUx Interrupt Control Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65068</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CCPN</name>
								<description>Current CPU Priority Number   CCPN. The Current CPU Priority Number  CCPN  bit field indicates the current priority level of the CPU. It is automatically updated by hardware on entry or exit of Interrupt Service Routines  ISRs  and through the execution of a BISR instruction. CCPN can also be updated through an MTCR instruction.</description>
								<lsb>0</lsb>
								<msb>7</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>IE</name>
								<description>Global Interrupt Enable Bit   IE. The interrupt enable bit globally enables the CPU service request system. Whether a service request is delivered to the CPU depends on the individual Service Request Enable Bits  SRE  in the SRNs  and the current state of the CPU. ICR.IE is automatically updated by hardware on entry and exit of an Interrupt Service Routine  ISR . ICR.IE is cleared to 0 when an interrupt is taken  and is restored to the previous value when the ISR executes an RFE instruction to terminate itself. ICR.IE can also be updated through the execution of the ENABLE  DISABLE  MTCR  and BISR instructions.</description>
								<lsb>15</lsb>
								<msb>15</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Interrupt system is globally disabled</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Interrupt system is globally enabled</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>PIPN</name>
								<description>Pending Interrupt Priority Number   PIPN. A read only bit field that is updated by the ICU at the end of each interrupt arbitration process. It indicates the priority number of the pending service request. ICR.PIPN is set to 0 when no request is pending  and at the beginning of each new arbitration process. ...</description>
								<lsb>16</lsb>
								<msb>23</msb>
								<access>read-only</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>00 No valid pending request.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>01 Request pending  lowest priority.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_255255</name>
										<description>FF Request pending  highest priority.</description>
										<value>255</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>FCX</name>
						<description>CPUx Free CSA List Head Pointer
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65080</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>FCXO</name>
								<description>FCX Offset Address Field   FCXO. The FCXO and FCXS fields together form the FCX pointer  which points to the next available CSA.</description>
								<lsb>0</lsb>
								<msb>15</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>FCXS</name>
								<description>FCX Segment Address Field   FCXS. Used in conjunction with the FCXO field.</description>
								<lsb>16</lsb>
								<msb>19</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>LCX</name>
						<description>CPUx Free CSA List Limit Pointer
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65084</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>LCXO</name>
								<description>LCX Offset Field   LCXO. The LCXO and LCXS fields form the pointer LCX  which points to the last available CSA.</description>
								<lsb>0</lsb>
								<msb>15</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>LCXS</name>
								<description>LCX Segment Address   LCXS. This field is used in conjunction with the LCXO field.</description>
								<lsb>16</lsb>
								<msb>19</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>CUS_ID</name>
						<description>CPUx Customer ID register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65104</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967288</resetMask>
						<fields>
							<field>
								<name>CID</name>
								<description>Customer ID   CID. See CROSSREFERENCE for the relation between CUS ID and CORE ID for each derivative</description>
								<lsb>0</lsb>
								<msb>2</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<dim>16</dim>
						<dimIncrement>4</dimIncrement>
						<name>Dy[%s]</name>
						<description>CPUx Data General Purpose Register 0
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65280</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>0</resetMask>
						<fields>
							<field>
								<name>DATA</name>
								<description>Data Register   DATA. General purpose registers</description>
								<lsb>0</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<dim>16</dim>
						<dimIncrement>4</dimIncrement>
						<name>Ay[%s]</name>
						<description>CPUx Address General Purpose Register 0
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65408</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>0</resetMask>
						<fields>
							<field>
								<name>ADDR</name>
								<description>Address Register   ADDR. General purpose registers</description>
								<lsb>0</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>CPXE_0</name>
						<description>CPUx Code Protection Execute Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57344</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>XE_n</name>
								<description>Execute Enable Range select   XE n </description>
								<lsb>0</lsb>
								<msb>9</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Code Protection        Range n not enabled for execution</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Code Protection        Range n enabled for execution</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CPXE_1</name>
						<description>CPUx Code Protection Execute Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57348</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>XE_n</name>
								<description>Execute Enable Range select   XE n </description>
								<lsb>0</lsb>
								<msb>9</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Code Protection        Range n not enabled for execution</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Code Protection        Range n enabled for execution</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CPXE_2</name>
						<description>CPUx Code Protection Execute Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57352</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>XE_n</name>
								<description>Execute Enable Range select   XE n </description>
								<lsb>0</lsb>
								<msb>9</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Code Protection        Range n not enabled for execution</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Code Protection        Range n enabled for execution</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CPXE_3</name>
						<description>CPUx Code Protection Execute Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57356</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>XE_n</name>
								<description>Execute Enable Range select   XE n </description>
								<lsb>0</lsb>
								<msb>9</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Code Protection        Range n not enabled for execution</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Code Protection        Range n enabled for execution</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPRE_0</name>
						<description>CPUx Data Protection Read Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57360</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>RE_n</name>
								<description>Read Enable Range Select   RE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data read</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data read</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPRE_1</name>
						<description>CPUx Data Protection Read Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57364</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>RE_n</name>
								<description>Read Enable Range Select   RE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data read</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data read</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPRE_2</name>
						<description>CPUx Data Protection Read Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57368</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>RE_n</name>
								<description>Read Enable Range Select   RE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data read</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data read</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPRE_3</name>
						<description>CPUx Data Protection Read Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57372</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>RE_n</name>
								<description>Read Enable Range Select   RE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data read</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data read</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPWE_0</name>
						<description>CPUx Data Protection Write Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57376</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>WE_n</name>
								<description>Write Enable Range Select   WE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data write</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data write</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPWE_1</name>
						<description>CPUx Data Protection Write Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57380</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>WE_n</name>
								<description>Write Enable Range Select   WE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data write</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data write</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPWE_2</name>
						<description>CPUx Data Protection Write Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57384</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>WE_n</name>
								<description>Write Enable Range Select   WE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data write</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data write</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPWE_3</name>
						<description>CPUx Data Protection Write Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57388</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>WE_n</name>
								<description>Write Enable Range Select   WE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data write</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data write</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CPXE_4</name>
						<description>CPUx Code Protection Execute Enable Register Set 5
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57408</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>XE_n</name>
								<description>Execute Enable Range select   XE n </description>
								<lsb>0</lsb>
								<msb>9</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Code Protection        Range n not enabled for execution</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Code Protection        Range n enabled for execution</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CPXE_5</name>
						<description>CPUx Code Protection Execute Enable Register Set 5
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57412</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>XE_n</name>
								<description>Execute Enable Range select   XE n </description>
								<lsb>0</lsb>
								<msb>9</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Code Protection        Range n not enabled for execution</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Code Protection        Range n enabled for execution</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPRE_4</name>
						<description>CPUx Data Protection Read Enable Register Set 5
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57424</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>RE_n</name>
								<description>Read Enable Range Select   RE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data read</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data read</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPRE_5</name>
						<description>CPUx Data Protection Read Enable Register Set 5
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57428</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>RE_n</name>
								<description>Read Enable Range Select   RE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data read</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data read</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPWE_4</name>
						<description>CPUx Data Protection Write Enable Register Set 5
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57440</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>WE_n</name>
								<description>Write Enable Range Select   WE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data write</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data write</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPWE_5</name>
						<description>CPUx Data Protection Write Enable Register Set 5
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57444</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>WE_n</name>
								<description>Write Enable Range Select   WE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data write</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data write</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CCTRL</name>
						<description>CPUx Counter Control
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64512</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CM</name>
								<description>Counter Mode   CM</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Normal Mode.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Task Mode.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>CE</name>
								<description>Count Enable   CE</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Disable the counters  CCNT  ICNT  M1CNT  M2CNT  M3CNT.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Enable the counters  CCNT  ICNT  M1CNT  M2CNT  M3CNT.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>M1</name>
								<description>M1CNT Configuration   M1</description>
								<lsb>2</lsb>
								<msb>4</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>M2</name>
								<description>M2CNT Configuration   M2</description>
								<lsb>5</lsb>
								<msb>7</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>M3</name>
								<description>M3CNT Configuration   M3</description>
								<lsb>8</lsb>
								<msb>10</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>CCNT</name>
						<description>CPUx CPU Clock Cycle Count
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64516</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CountValue</name>
								<description>Count Value   CountValue. Current Count of the CPU Clock Cycles.</description>
								<lsb>0</lsb>
								<msb>30</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>SOvf</name>
								<description>Sticky Overflow Bit   SOvf. This bit is set by hardware when count value  30 0    31 h7FFF FFFF. It can only be cleared by software.</description>
								<lsb>31</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>ICNT</name>
						<description>CPUx Instruction Count
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64520</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CountValue</name>
								<description>Count Value   CountValue. Count of the Instructions Executed.</description>
								<lsb>0</lsb>
								<msb>30</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>SOvf</name>
								<description>Sticky Overflow Bit   SOvf. This bit is set by hardware when count value  30 0    31 h7FFF FFFF. It can only be cleared by software.</description>
								<lsb>31</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>M1CNT</name>
						<description>CPUx Multi Count Register 1
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64524</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CountValue</name>
								<description>Count Value   CountValue. Count of the Selected Event.</description>
								<lsb>0</lsb>
								<msb>30</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>SOvf</name>
								<description>Sticky Overflow Bit   SOvf. This bit is set by hardware when count value  30 0    31 h7FFF FFFF. It can only be cleared by software.</description>
								<lsb>31</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>M2CNT</name>
						<description>CPUx Multi Count Register 2
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64528</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CountValue</name>
								<description>Count Value   CountValue. Count of the Selected Event.</description>
								<lsb>0</lsb>
								<msb>30</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>SOvf</name>
								<description>Sticky Overflow Bit   SOvf. This bit is set by hardware when count value  30 0    31 h7FFF FFFF. It can only be cleared by software.</description>
								<lsb>31</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>M3CNT</name>
						<description>CPUx Multi Count Register 3
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64532</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CountValue</name>
								<description>Count Value   CountValue. Count of the Selected Event.</description>
								<lsb>0</lsb>
								<msb>30</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>SOvf</name>
								<description>Sticky Overflow Bit   SOvf. This bit is set by hardware when count value  30 0    31 h7FFF FFFF. It can only be cleared by software.</description>
								<lsb>31</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DBGSR</name>
						<description>CPUx Debug Status Register
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64768</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>DE</name>
								<description>Debug Enable   DE. Determines whether the CDC is enabled or not.</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-only</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 The CDC is disabled.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 The CDC is enabled.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>HALT</name>
								<description>CPU Halt Request   Status Field   HALT. HALT can be set or cleared by software. HALT 0  is the actual Halt bit. HALT 1  is a mask bit to specify whether or not HALT 0  is to be updated on a software write. HALT 1  is always read as 0. HALT 1  must be set to 1 in order to update HALT 0  by software  R  read  W  write .</description>
								<lsb>1</lsb>
								<msb>2</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>00 R  CPU running.  W  HALT 0  unchanged.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>01 R  CPU halted.  W  HALT 0  unchanged.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>10 R  Not Applicable. W  reset HALT 0 .</description>
										<value>2</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_33</name>
										<description>11 R  Not Applicable. W  If DBGSR.DE    1  The CDC is enabled   set HALT 0 . If DBGSR.DE    0  The CDC is not enabled   HALT 0  is left unchanged.</description>
										<value>3</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>SIH</name>
								<description>Suspend in Halt   SIH. State of the Suspend In signal.</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-only</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 The Suspend In signal is negated. The CPU is not in Halt Mode   except when the Halt mechanism is set following a Debug Event or a write to DBGSR.HALT .</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 The Suspend In signal is asserted. The CPU is in Halt Mode.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>SUSP</name>
								<description>Current State of the Core Suspend Out Signal   SUSP</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Core suspend out inactive.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Core suspend out active.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>PREVSUSP</name>
								<description>Previous State of Core Suspend Out Signal   PREVSUSP. Updated when a Debug Event causes a hardware update of DBGSR.SUSP. This field is not updated for writes to DBGSR.SUSP.</description>
								<lsb>6</lsb>
								<msb>6</msb>
								<access>read-only</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Previous core suspend out inactive.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Previous core suspend out active.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>PEVT</name>
								<description>Posted Event   PEVT</description>
								<lsb>7</lsb>
								<msb>7</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 No posted event.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Posted event.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>EXEVT</name>
						<description>CPUx External Event Register
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64776</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>EVTA</name>
								<description>Event Associated   EVTA. Specifies the Debug Action associated with the Debug Event </description>
								<lsb>0</lsb>
								<msb>2</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>000 BOD 0  Disabled. BOD 1  Disabled.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>001 BOD 0  Pulse BRKOUT Signal. BOD 1  None.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>010 BOD 0  Halt and pulse BRKOUT Signal. BOD 1  Halt.</description>
										<value>2</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_33</name>
										<description>011 BOD 0  Breakpoint trap and pulse. BRKOUT Signal. BOD 1  Breakpoint trap.</description>
										<value>3</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_44</name>
										<description>100 BOD 0  Breakpoint interrupt 0 and pulse BRKOUT Signal. BOD 1  Breakpoint interrupt 0.</description>
										<value>4</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_55</name>
										<description>101 BOD 0  If implemented  breakpoint interrupt 1 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 1. If not implemented  None.</description>
										<value>5</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_66</name>
										<description>110 BOD 0  If implemented  breakpoint interrupt 2 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 2. If not implemented  None.</description>
										<value>6</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_77</name>
										<description>111 BOD 0  If implemented  breakpoint interrupt 3 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 3. If not implemented  None.</description>
										<value>7</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>BBM</name>
								<description>Break Before Make  BBM  or Break After Make  BAM  Selection   BBM</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Break after make  BAM .</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Break before make  BBM .</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>BOD</name>
								<description>Breakout Disable   BOD</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 BRKOUT signal asserted according to the Debug Action specified in the EVTA field.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 BRKOUT signal not asserted. This takes priority over any assertion generated by the EVTA field.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>SUSP</name>
								<description>CDC Suspend Out Signal State   SUSP. Value to be assigned to the CDC suspend out signal when the Debug Event is raised.</description>
								<lsb>5</lsb>
								<msb>5</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CNT</name>
								<description>Counter   CNT. When this event occurs adjust the control of the performance counters in task mode as follows </description>
								<lsb>6</lsb>
								<msb>7</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>00 No change.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>01 Start the performance counters.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>10 Stop the performance counters.</description>
										<value>2</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_33</name>
										<description>11 Toggle the performance counter control  i.e. start it if it is currently stopped  stop it if it is currently running .</description>
										<value>3</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CREVT</name>
						<description>CPUx Core Register Access Event
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64780</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>EVTA</name>
								<description>Event Associated   EVTA. Debug Action associated with the Debug Event </description>
								<lsb>0</lsb>
								<msb>2</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>000 BOD 0  Disabled. BOD 1  Disabled.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>001 BOD 0  Pulse BRKOUT Signal. BOD 1  None.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>010 BOD 0  Halt and pulse BRKOUT Signal. BOD 1  Halt.</description>
										<value>2</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_33</name>
										<description>011 BOD 0  Breakpoint trap and pulse BRKOUT Signal. BOD 1  Breakpoint trap.</description>
										<value>3</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_44</name>
										<description>100 BOD 0  Breakpoint interrupt 0 and pulse BRKOUT Signal. BOD 1  Breakpoint interrupt 0.</description>
										<value>4</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_55</name>
										<description>101 BOD 0  If implemented  breakpoint interrupt 1 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 1. If not implemented  None.</description>
										<value>5</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_66</name>
										<description>110 BOD 0  If implemented  breakpoint interrupt 2 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 2. If not implemented  None.</description>
										<value>6</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_77</name>
										<description>111 BOD 0  If implemented  breakpoint interrupt 3 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 3. If not implemented  None.</description>
										<value>7</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>BBM</name>
								<description>Break Before Make  BBM  or Break After Make  BAM  Selection   BBM</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Break after make  BAM .</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Break before make  BBM .</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>BOD</name>
								<description>Breakout Disable   BOD</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 BRKOUT signal asserted according to the action specified in the EVTA field.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 BRKOUT signal not asserted. This takes priority over any assertion generated by the EVTA field.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>SUSP</name>
								<description>CDC Suspend Out Signal State   SUSP. Value to be assigned to the CDC suspend out signal when the Debug Event is raised.</description>
								<lsb>5</lsb>
								<msb>5</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CNT</name>
								<description>Counter   CNT. When this event occurs adjust the control of the performance counters in task mode as follows </description>
								<lsb>6</lsb>
								<msb>7</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>00 No change.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>01 Start the performance counters.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>10 Stop the performance counters.</description>
										<value>2</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_33</name>
										<description>11 Toggle the performance counter control  i.e. start it if it is currently stopped  stop it if it is currently running .</description>
										<value>3</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>SWEVT</name>
						<description>CPUx Software Debug Event
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64784</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>EVTA</name>
								<description>Event Associated   EVTA. Debug Action associated with the Debug Event </description>
								<lsb>0</lsb>
								<msb>2</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>000 BOD 0  Disabled. BOD 1  Disabled.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>001 BOD 0  Pulse BRKOUT Signal. BOD 1  None.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>010 BOD 0  Halt and pulse BRKOUT Signal. BOD 1  Halt.</description>
										<value>2</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_33</name>
										<description>011 BOD 0  Breakpoint trap and pulse BRKOUT Signal. BOD 1  Breakpoint trap.</description>
										<value>3</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_44</name>
										<description>100 BOD 0  Breakpoint interrupt 0 and pulse BRKOUT Signal. BOD 1  Breakpoint interrupt 0.</description>
										<value>4</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_55</name>
										<description>101 BOD 0  If implemented  breakpoint interrupt 1 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 1. If not implemented  None.</description>
										<value>5</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_66</name>
										<description>110 BOD 0  If implemented  breakpoint interrupt 2 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 2. If not implemented  None.</description>
										<value>6</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_77</name>
										<description>111 BOD 0  If implemented  breakpoint interrupt 3 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 3. If not implemented  None.</description>
										<value>7</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>BBM</name>
								<description>Break Before Make  BBM  or Break After Make  BAM  Selection   BBM</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Break after make  BAM .</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Break before make  BBM .</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>BOD</name>
								<description>Breakout Disable   BOD</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 BRKOUT signal asserted according to the action specified in the EVTA field.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 BRKOUT signal not asserted. This takes priority over any assertion generated by the EVTA field.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>SUSP</name>
								<description>CDC Suspend Out Signal State   SUSP. Value to be assigned to the CDC suspend out signal when the event is raised.</description>
								<lsb>5</lsb>
								<msb>5</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CNT</name>
								<description>Counter   CNT. When this event occurs adjust the control of the performance counters in task mode as follows </description>
								<lsb>6</lsb>
								<msb>7</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>00 No change.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>01 Start the performance counters.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>10 Stop the performance counters.</description>
										<value>2</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_33</name>
										<description>11 Toggle the performance counter control  i.e. start it if it is currently stopped  stop it if it is currently running .</description>
										<value>3</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>TRIG_ACC</name>
						<description>CPUx TriggerAddressx
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64816</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>T0</name>
								<description>Trigger 0   T0. active since last cleared</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>T1</name>
								<description>Trigger 1   T1. active since last cleared</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>T2</name>
								<description>Trigger 2   T2. active since last cleared</description>
								<lsb>2</lsb>
								<msb>2</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>T3</name>
								<description>Trigger 3   T3. active since last cleared</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>T4</name>
								<description>Trigger 4   T4. active since last cleared</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>T5</name>
								<description>Trigger 5   T5. active since last cleared</description>
								<lsb>5</lsb>
								<msb>5</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>T6</name>
								<description>Trigger 6   T6. active since last cleared</description>
								<lsb>6</lsb>
								<msb>6</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>T7</name>
								<description>Trigger 7   T7. active since last cleared</description>
								<lsb>7</lsb>
								<msb>7</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DMS</name>
						<description>CPUx Debug Monitor Start Address
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>64832</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>0</resetMask>
						<fields>
							<field>
								<name>DMSValue</name>
								<description>Debug Monitor Start Address   DMSValue. The address at which monitor code execution begins when a breakpoint trap is taken.</description>
								<lsb>1</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DCX</name>
						<description>CPUx Debug Context Save Area Pointer
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>64836</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>0</resetMask>
						<fields>
							<field>
								<name>DCXValue</name>
								<description>Debug Context Save Area Pointer   DCXValue. Address where the debug context is stored following a breakpoint trap.</description>
								<lsb>6</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DBGTCR</name>
						<description>CPUx Debug Trap Control Register
 resetvalue={Application Reset:0x1}</description>
						<addressOffset>64840</addressOffset>
						<size>32</size>
						<resetValue>1</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>DTA</name>
								<description>Debug Trap Active Bit   DTA. A breakpoint trap may only be taken in the condition DTA    0. Taking a breakpoint trap sets the DTA bit to one. Further breakpoint traps are therefore disabled until such time as the breakpoint trap handler clears the DTA bit or until the breakpoint trap handler terminates with a RFM.</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 No breakpoint trap is active.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 A breakpoint Trap is active</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>SEGEN</name>
						<description>CPUx SRI Error Generation Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>4144</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>ADFLIP</name>
								<description>Address ECC Bit Flip   ADFLIP. SRI address ECC Bits to be flipped on the next read or write transaction from the DMI when enabled by AE.</description>
								<lsb>0</lsb>
								<msb>7</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 No Flip</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Flip</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>ADTYPE</name>
								<description>Type of error   ADTYPE</description>
								<lsb>8</lsb>
								<msb>9</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>00 Data Master Address Phase</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>01 Data Master Write Data</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>10 Data Slave Read Data</description>
										<value>2</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>AE</name>
								<description>Activate Error Enable   AE. Enabled the selective inverting of SRI ECC packet bits defined by ADFLIP. This bit will be cleared by hardware after the next SRI read or write transaction from the DMI.</description>
								<lsb>31</lsb>
								<msb>31</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Not Enabled</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Enabled</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DCON2</name>
						<description>CPUx Data Control Register 2
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>36864</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>0</resetMask>
						<fields>
							<field>
								<name>DCACHE_SZE</name>
								<description>Data Cache Size   DCACHE SZE. In KBytes</description>
								<lsb>0</lsb>
								<msb>15</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>DSCRATCH_SZE</name>
								<description>Data Scratch Size   DSCRATCH SZE. In KBytes</description>
								<lsb>16</lsb>
								<msb>31</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DSTR</name>
						<description>CPUx Data Synchronous Trap Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>36880</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>SRE</name>
								<description>Scratch Range Error   SRE. A scratch Range Error occurs whenever an access to the data scratch is outside the range of the SRAM.</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>GAE</name>
								<description>Global Address Error   GAE. Load or store to local code scratch address outside of the lower 1MByte.</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>LBE</name>
								<description>Load Bus Error   LBE. A Load Bus Error will be set whenever the SRI flags an error due a load from external memory.</description>
								<lsb>2</lsb>
								<msb>2</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>DRE</name>
								<description>Local DLMU Range Error   DRE. A DLMU Range Error occurs whenever an access to the local DLMU region is outside the physically implemented memory.</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CRE</name>
								<description>Cache Refill Error   CRE. A Cache Refill Error will be set whenever the SRI flags an error due a cache refill from external memory.</description>
								<lsb>6</lsb>
								<msb>6</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>DTME</name>
								<description>DTAG MSIST Error   DTME. Access to memory mapped DTAG range outside of physically implemented memory.</description>
								<lsb>14</lsb>
								<msb>14</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>LOE</name>
								<description>Load Overlay Error   LOE. Load to invalid overlay address.</description>
								<lsb>15</lsb>
								<msb>15</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>SDE</name>
								<description>Segment Difference Error   SDE. Load or store access where base address is in different segment to access address.</description>
								<lsb>16</lsb>
								<msb>16</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>SCE</name>
								<description>Segment Crossing Error   SCE. Load or store access across segment boundary.</description>
								<lsb>17</lsb>
								<msb>17</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CAC</name>
								<description>CSFR Access Error   CAC. Load or store to local CSFR space.</description>
								<lsb>18</lsb>
								<msb>18</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>MPE</name>
								<description>Memory Protection Error   MPE. Data access violating memory protection.</description>
								<lsb>19</lsb>
								<msb>19</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CLE</name>
								<description>Context Location Error   CLE. Context operation to invalid location.</description>
								<lsb>20</lsb>
								<msb>20</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>ALN</name>
								<description>Alignment Error   ALN. Data access causing alignment error.</description>
								<lsb>24</lsb>
								<msb>24</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DATR</name>
						<description>CPUx Data Asynchronous Trap Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>36888</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>SBE</name>
								<description>Store Bus Error   SBE</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CWE</name>
								<description>Cache Writeback Error   CWE</description>
								<lsb>9</lsb>
								<msb>9</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CFE</name>
								<description>Cache Flush Error   CFE</description>
								<lsb>10</lsb>
								<msb>10</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>SOE</name>
								<description>Store Overlay Error   SOE</description>
								<lsb>14</lsb>
								<msb>14</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DEADD</name>
						<description>CPUx Data Error Address Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>36892</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>ERROR_ADDRESS</name>
								<description>Error Address   ERROR ADDRESS</description>
								<lsb>0</lsb>
								<msb>31</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DCON0</name>
						<description>CPUx Data Memory Control Register
 resetvalue={Application Reset:0x2}</description>
						<addressOffset>36928</addressOffset>
						<size>32</size>
						<resetValue>2</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>DCBYP</name>
								<description>Data Cache Bypass   DCBYP</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 DCache   DRB enabled</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 DCache   DRB Bypass  disabled </description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>PSTR</name>
						<description>CPUx Program Synchronous Trap Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>37376</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>FRE</name>
								<description>Fetch Range Error   FRE. A Fetch Range Error occurs whenever an access to the Program Scratch is outside the range of the SRAM.</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>FBE</name>
								<description>Fetch Bus Error   FBE. A Fetch bus error will be set whenever the SRI flags an error due a fetch from external memory. This will be set for both direct fetches from the bus and for cache refills.</description>
								<lsb>2</lsb>
								<msb>2</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>FPE</name>
								<description>Fetch Peripheral Error   FPE. A Fetch peripheral error will be flagged whenever a fetch is attempted to peripheral space.</description>
								<lsb>12</lsb>
								<msb>12</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>FME</name>
								<description>Fetch MSIST Error   FME. During SIST mode  a fetch from the PTAG will cause a PSE trap to occur.</description>
								<lsb>14</lsb>
								<msb>14</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PCON1</name>
						<description>CPUx Program Control 1
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>37380</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>PCINV</name>
								<description>Program Cache Invalidate   PCINV</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Write  No effect  normal instruction cache operation. Read   Normal operation  instruction cache available</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Write   Initiate invalidation of entire instruction cache. Read  Instruction cache invalidation in progress. Instruction cache unavailable.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>PBINV</name>
								<description>Program Buffer Invalidate   PBINV. Write Operation  This field returns 0 when read.</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Write  No effect. Normal program line buffer operation.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Write  Invalidate the program line buffer.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>PCON2</name>
						<description>CPUx Program Control 2
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>37384</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>0</resetMask>
						<fields>
							<field>
								<name>PCACHE_SZE</name>
								<description>Program Cache Size  ICACHE  in KBytes   PCACHE SZE. In KBytes</description>
								<lsb>0</lsb>
								<msb>15</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>PSCRATCH_SZE</name>
								<description>Program Scratch Size in KBytes   PSCRATCH SZE. In KBytes</description>
								<lsb>16</lsb>
								<msb>31</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PCON0</name>
						<description>CPUx Program Control 0
 resetvalue={Application Reset:0x2}</description>
						<addressOffset>37388</addressOffset>
						<size>32</size>
						<resetValue>2</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>PCBYP</name>
								<description>Program Cache Bypass   PCBYP</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Cache enabled</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Cache bypass  disabled </description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
				</registers>
			</peripheral>
			<peripheral>
				<name>CPU1</name>
				<version>100</version>
				<description>CPU</description>
				<alternatePeripheral>CPU0</alternatePeripheral>
				<baseAddress>0</baseAddress>
				<addressBlock>
					<offset>0</offset>
					<size>65472</size>
					<usage>registers</usage>
				</addressBlock>
				<registers>
					<cluster>
						<dim>18</dim>
						<dimIncrement>8</dimIncrement>
						<name>DPR[%s]</name>
						<description>DPR</description>
						<addressOffset>49152</addressOffset>
						<register>
							<name>DPRy_L</name>
							<description>CPUx Data Protection Range 0  Lower Bound Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>0</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>LOWBND</name>
									<description>DPRy Lower Boundary Address   LOWBND</description>
									<lsb>3</lsb>
									<msb>31</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
						<register>
							<name>DPRy_U</name>
							<description>CPUx Data Protection Range 0  Upper Bound Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>4</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>UPPBND</name>
									<description>DPRy Upper Boundary Address   UPPBND</description>
									<lsb>3</lsb>
									<msb>31</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
					</cluster>
					<cluster>
						<dim>10</dim>
						<dimIncrement>8</dimIncrement>
						<name>CPR[%s]</name>
						<description>CPR</description>
						<addressOffset>53248</addressOffset>
						<register>
							<name>CPRy_L</name>
							<description>CPUx Code Protection Range 0 Lower Bound Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>0</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>LOWBND</name>
									<description>CPRy Lower Boundary Address   LOWBND</description>
									<lsb>5</lsb>
									<msb>31</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
						<register>
							<name>CPRy_U</name>
							<description>CPUx Code Protection Range 0 Upper Bound Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>4</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>UPPBND</name>
									<description>CPR0 m Upper Boundary Address   UPPBND</description>
									<lsb>5</lsb>
									<msb>31</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
					</cluster>
					<cluster>
						<name>TPS</name>
						<description>TPS</description>
						<addressOffset>58368</addressOffset>
						<register>
							<name>CON</name>
							<description>CPUx Temporal Protection System Control Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>0</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>TEXP0</name>
									<description>Timer0 Expired Flag   TEXP0. Set when the corresponding timer expires. Cleared on any write to the  TIMER0 register.</description>
									<lsb>0</lsb>
									<msb>0</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>TEXP1</name>
									<description>Timer1 Expired Flag   TEXP1. Set when the corresponding timer expires. Cleared on any write to the  TIMER1 register.</description>
									<lsb>1</lsb>
									<msb>1</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>TEXP2</name>
									<description>Timer1 Expired Flag   TEXP2. Set when the corresponding timer expires. Cleared on any write to the  TIMER1 register.</description>
									<lsb>2</lsb>
									<msb>2</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>TTRAP</name>
									<description>Temporal Protection Trap   TTRAP. If set  indicates that a TAE trap has been requested. Any subsequent TAE traps are disabled. A write clears the flag and re enables TAE traps.</description>
									<lsb>16</lsb>
									<msb>16</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
						<register>
							<dim>3</dim>
							<dimIncrement>4</dimIncrement>
							<name>TIMER[%s]</name>
							<description>CPUx Temporal Protection System Timer Register 0
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>4</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>Timer</name>
									<description>Temporal Protection Timer   Timer. Writing zero de activates the Timer. Writing a non zero value starts the Timer. Any write clears the corresponding TPS CON.TEXP flag. Read returns the current Timer value.</description>
									<lsb>0</lsb>
									<msb>31</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
					</cluster>
					<cluster>
						<name>TPS_EXTIM</name>
						<description>TPS EXTIM</description>
						<addressOffset>58432</addressOffset>
						<register>
							<name>ENTRY_LVAL</name>
							<description>CPUx Exception Entry Timer Load Value
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>0</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>ENTRY_LVAL</name>
									<description>Exception Entry Timer Load value   ENTRY LVAL. Value loaded into the exception entry timer on detection of an enabled exception. Bits  3 0  are constrained to be 0</description>
									<lsb>4</lsb>
									<msb>11</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
						<register>
							<name>ENTRY_CVAL</name>
							<description>CPUx Exception Entry Timer Current Value
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>4</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>ENTRY_CVAL</name>
									<description>Exception Entry Timer Current Value   ENTRY CVAL. Current value of the exception entry timer.</description>
									<lsb>0</lsb>
									<msb>11</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
						<register>
							<name>EXIT_LVAL</name>
							<description>CPUx Exception Exit  Timer Load Value
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>8</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>EXIT_LVAL</name>
									<description>Exception Exit Timer Load value   EXIT LVAL. Value loaded into the exception exit timer on detection of an enabled exception. Bits  3 0  are constrained to be 0</description>
									<lsb>4</lsb>
									<msb>23</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
						<register>
							<name>EXIT_CVAL</name>
							<description>CPUx Exception Exit Timer Current Value
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>12</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>EXIT_CVAL</name>
									<description>Exception Exit Timer Current Value   EXIT CVAL. Current value of the exception exit timer.</description>
									<lsb>0</lsb>
									<msb>23</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
						<register>
							<name>CLASS_EN</name>
							<description>CPUx Exception Timer Class Enable Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>16</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>EXTIM_CLASS_EN</name>
									<description>Exception Timer Class Enables   EXTIM CLASS EN. Trap Class enables for exception timer.</description>
									<lsb>0</lsb>
									<msb>7</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
						<register>
							<name>STAT</name>
							<description>CPUx Exception Timer Status Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>20</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>EXIT_TIN</name>
									<description>Exception Exit Timer TIN   EXIT TIN. Exception Exit Timer TIN of triggering trap.</description>
									<lsb>0</lsb>
									<msb>7</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>EXIT_CLASS</name>
									<description>Exception Exit Timer Class   EXIT CLASS. Exception exit Timer Class of triggering trap.</description>
									<lsb>8</lsb>
									<msb>10</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>EXIT_AT</name>
									<description>Exception Exit Timer Alarm Triggered   EXIT AT. Exception Exit Timer Alarm triggered sticky bit. Alarm triggered since last cleared.</description>
									<lsb>15</lsb>
									<msb>15</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>ENTRY_TIN</name>
									<description>Exception Entry Timer TIN   ENTRY TIN. Exception Entry Timer TIN of triggering trap.</description>
									<lsb>16</lsb>
									<msb>23</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>ENTRY_CLASS</name>
									<description>Exception Entry Timer Class   ENTRY CLASS. Exception Entry Timer Class of triggering trap.</description>
									<lsb>24</lsb>
									<msb>26</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>ENTRY_AT</name>
									<description>Exception Entry Timer Alarm Triggered   ENTRY AT. Exception Entry Timer Alarm triggered sticky bit. Alarm triggered since last cleared.</description>
									<lsb>31</lsb>
									<msb>31</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
						<register>
							<name>FCX</name>
							<description>CPUx Exception Timer FCX Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>24</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>EXIT_FCX</name>
									<description>Exception Exit Timer FCX   EXIT FCX. Exception Exit Timer FCX of triggering trap.</description>
									<lsb>0</lsb>
									<msb>19</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
					</cluster>
					<cluster>
						<name>FPU_TRAP</name>
						<description>FPU TRAP</description>
						<addressOffset>40960</addressOffset>
						<register>
							<name>CON</name>
							<description>CPUx Trap Control Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>0</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>TST</name>
									<description>Trap Status   TST</description>
									<lsb>0</lsb>
									<msb>0</msb>
									<access>read-only</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 No instruction captured.  The next enabled exception will cause the exceptional instruction to be captured.</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>1 Instruction captured. No further enabled exceptions will be captured until TST is cleared.</description>
											<value>1</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>TCL</name>
									<description>Trap Clear   TCL. Read  always reads as 0.</description>
									<lsb>1</lsb>
									<msb>1</msb>
									<access>write-only</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 No effect.</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>1 Clears the trapped instruction  TST will be negated .</description>
											<value>1</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>RM</name>
									<description>Captured Rounding Mode   RM. The rounding mode of the captured instruction. Only valid when TST is asserted. Note that this is the rounding mode supplied to the FPU for the exceptional instruction. UPDFL instructions may cause a trap and change the rounding mode. In this case the RM bits capture the input rounding mode</description>
									<lsb>8</lsb>
									<msb>9</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>FXE</name>
									<description>FX Trap Enable   FXE. When set  an instruction generating an FX exception will trigger a trap.</description>
									<lsb>18</lsb>
									<msb>18</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>FUE</name>
									<description>FU Trap Enable   FUE. When set  an instruction generating an FU exception will trigger a trap.</description>
									<lsb>19</lsb>
									<msb>19</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>FZE</name>
									<description>FZ Trap Enable   FZE. When set  an instruction generating an FZ exception will trigger a trap.</description>
									<lsb>20</lsb>
									<msb>20</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>FVE</name>
									<description>FV Trap Enable   FVE. When set  an instruction generating an FV exception will trigger a trap.</description>
									<lsb>21</lsb>
									<msb>21</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>FIE</name>
									<description>FI Trap Enable   FIE. When set  an instruction generating an FI exception will trigger a trap.</description>
									<lsb>22</lsb>
									<msb>22</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>FX</name>
									<description>Captured FX   FX. Asserted if the captured instruction asserted FX. Only valid when TST is asserted.</description>
									<lsb>26</lsb>
									<msb>26</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>FU</name>
									<description>Captured FU   FU. Asserted if the captured instruction asserted FU. Only valid when TST is asserted.</description>
									<lsb>27</lsb>
									<msb>27</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>FZ</name>
									<description>Captured FZ   FZ. Asserted if the captured instruction asserted FZ. Only valid when TST is asserted</description>
									<lsb>28</lsb>
									<msb>28</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>FV</name>
									<description>Captured FV   FV. Asserted if the captured instruction asserted FV. Only valid when TST is asserted</description>
									<lsb>29</lsb>
									<msb>29</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>FI</name>
									<description>Captured FI   FI. Asserted if the captured instruction asserted FI. Only valid when TST is asserted</description>
									<lsb>30</lsb>
									<msb>30</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
						<register>
							<name>PC</name>
							<description>CPUx Trapping Instruction Program Counter Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>4</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>PC</name>
									<description>Captured Program Counter   PC. The program counter  virtual address  of the captured instruction. Only valid when FPU TRAP CON.TST is asserted.</description>
									<lsb>0</lsb>
									<msb>31</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
						<register>
							<name>OPC</name>
							<description>CPUx Trapping Instruction Opcode Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>8</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>OPC</name>
									<description>Captured Opcode   OPC. The secondary opcode of the captured instruction. When FPU TRAP OPC.FMT 0 only bits  3 0  are defined. OPC is valid only when FPU TRAP CON.TST is asserted.</description>
									<lsb>0</lsb>
									<msb>7</msb>
									<access>read-only</access>
								</field>
								<field>
									<name>FMT</name>
									<description>Captured Instruction Format   FMT. The format of the captured instruction s opcode. Only valid when FPU TRAP CON.TST is asserted.</description>
									<lsb>8</lsb>
									<msb>8</msb>
									<access>read-only</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 RRR</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>1 RR</description>
											<value>1</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>DREG</name>
									<description>Captured Destination Register   DREG. The destination register of the captured instruction. ... Only valid when FPU TRAP CON.TST is asserted.</description>
									<lsb>16</lsb>
									<msb>19</msb>
									<access>read-only</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 Data general purpose register 0.</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_1515</name>
											<description>F Data general purpose register 15.</description>
											<value>15</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
							</fields>
						</register>
						<register>
							<name>SRC1</name>
							<description>CPUx Trapping Instruction Operand Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>16</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>SRC1</name>
									<description>Captured SRC1 Operand   SRC1. The SRC1 operand of the captured instruction. Only valid when FPU TRAP CON.TST is asserted.</description>
									<lsb>0</lsb>
									<msb>31</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
						<register>
							<name>SRC2</name>
							<description>CPUx Trapping Instruction Operand Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>20</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>SRC2</name>
									<description>Captured SRC2 Operand   SRC2. The SRC2 operand of the captured instruction. Only valid when FPU TRAP CON.TST is asserted.</description>
									<lsb>0</lsb>
									<msb>31</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
						<register>
							<name>SRC3</name>
							<description>CPUx Trapping Instruction Operand Register
 resetvalue={Application Reset:0x0}</description>
							<addressOffset>24</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>SRC3</name>
									<description>Captured SRC3 Operand   SRC3. The SRC3 operand of the captured instruction. Only valid when FPU TRAP CON.TST is asserted.</description>
									<lsb>0</lsb>
									<msb>31</msb>
									<access>read-only</access>
								</field>
							</fields>
						</register>
					</cluster>
					<cluster>
						<dim>8</dim>
						<dimIncrement>8</dimIncrement>
						<name>TR[%s]</name>
						<description>Trigger</description>
						<addressOffset>61440</addressOffset>
						<register>
							<name>TRiEVT</name>
							<description>CPUx Trigger Event 0
 resetvalue={Debug Reset:0x0}</description>
							<addressOffset>0</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>EVTA</name>
									<description>Event Associated   EVTA. Specifies the Debug Action associated with the Debug Event </description>
									<lsb>0</lsb>
									<msb>2</msb>
									<access>read-write</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>000 BOD 0  Disabled. BOD 1  Disabled.</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>001 BOD 0  Pulse BRKOUT Signal. BOD 1  None.</description>
											<value>1</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_22</name>
											<description>010 BOD 0  Halt and pulse BRKOUT Signal. BOD 1  Halt.</description>
											<value>2</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_33</name>
											<description>011 BOD 0  Breakpoint trap and pulse BRKOUT Signal. BOD 1  Breakpoint trap.</description>
											<value>3</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_44</name>
											<description>100 BOD 0  Breakpoint interrupt 0 and pulse BRKOUT Signal. BOD 1  Breakpoint interrupt 0.</description>
											<value>4</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_55</name>
											<description>101 BOD 0  If implemented  breakpoint interrupt 1 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 1. If not implemented  None.</description>
											<value>5</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_66</name>
											<description>110 BOD 0  If implemented  breakpoint interrupt 2 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 2. If not implemented  None.</description>
											<value>6</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_77</name>
											<description>111 BOD 0  If implemented  breakpoint interrupt 3 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 3. If not implemented  None.</description>
											<value>7</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>BBM</name>
									<description>Break Before Make  BBM  or Break After Make  BAM  Selection   BBM. Code triggers BBM or BAM selection. Data access and data code combination access triggers can only create BAM Debug Events. When these triggers occur  TRnEVT.BBM is ignored.</description>
									<lsb>3</lsb>
									<msb>3</msb>
									<access>read-write</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 Code only triggers Break After Make  BAM .</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>1 Code only triggers Break Before Make  BBM .</description>
											<value>1</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>BOD</name>
									<description>Breakout Disable   BOD</description>
									<lsb>4</lsb>
									<msb>4</msb>
									<access>read-write</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 BRKOUT signal asserted according to the action specified in the EVTA field.</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>1 BRKOUT signal not asserted. This takes priority over any assertion generated by the EVTA field.</description>
											<value>1</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>SUSP</name>
									<description>CDC Suspend Out Signal State   SUSP. Value to be assigned to the CDC suspend out signal when the Debug Event is raised.</description>
									<lsb>5</lsb>
									<msb>5</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>CNT</name>
									<description>Counter   CNT. When this event occurs adjust the control of the performance counters in task mode as follows </description>
									<lsb>6</lsb>
									<msb>7</msb>
									<access>read-write</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>00 No change.</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>01 Start the performance counters.</description>
											<value>1</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_22</name>
											<description>10 Stop the performance counters.</description>
											<value>2</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_33</name>
											<description>11 Toggle the performance counter control  i.e. start it if it is currently stopped  stop it if it is currently running .</description>
											<value>3</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>TYP</name>
									<description>Input Selection   TYP</description>
									<lsb>12</lsb>
									<msb>12</msb>
									<access>read-write</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 Address</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>1 PC</description>
											<value>1</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>RNG</name>
									<description>Compare Type   RNG. Once an even numbered comparator has been set to range  the EVTR settings of its associated upper neighbour will be ignored.</description>
									<lsb>13</lsb>
									<msb>13</msb>
									<access>read-write</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_11</name>
											<description>1 Range</description>
											<value>1</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 Equality</description>
											<value>0</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>ASI_EN</name>
									<description>Enable ASI Comparison   ASI EN</description>
									<lsb>15</lsb>
									<msb>15</msb>
									<access>read-write</access>
									<enumeratedValues>
										<enumeratedValue>
											<name>Const_00</name>
											<description>0 No ASI comparison performed. Debug Trigger is valid for all processes.</description>
											<value>0</value>
										</enumeratedValue>
										<enumeratedValue>
											<name>Const_11</name>
											<description>1 Enable ASI comparison. Debug Events are only triggered when the current process ASI matches TRnEVT.ASI.</description>
											<value>1</value>
										</enumeratedValue>
									</enumeratedValues>
								</field>
								<field>
									<name>ASI</name>
									<description>Address Space Identifier   ASI. The ASI of the Debug Trigger process.</description>
									<lsb>16</lsb>
									<msb>20</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>AST</name>
									<description>Address Store   AST. Used in conjunction with TYP 0</description>
									<lsb>27</lsb>
									<msb>27</msb>
									<access>read-write</access>
								</field>
								<field>
									<name>ALD</name>
									<description>Address Load   ALD. Used in conjunction with TYP 0</description>
									<lsb>28</lsb>
									<msb>28</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
						<register>
							<name>TRiADR</name>
							<description>CPUx Trigger Address 0
 resetvalue={Debug Reset:0x0}</description>
							<addressOffset>4</addressOffset>
							<size>32</size>
							<resetValue>0</resetValue>
							<resetMask>4294967295</resetMask>
							<fields>
								<field>
									<name>ADDR</name>
									<description>Comparison Address   ADDR. For PC comparison  bit 0  is always zero.</description>
									<lsb>0</lsb>
									<msb>31</msb>
									<access>read-write</access>
								</field>
							</fields>
						</register>
					</cluster>
					<register>
						<name>SMACON</name>
						<description>CPUx SIST Mode Access Control Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>36876</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>IODT</name>
								<description>In Order Data Transactions   IODT</description>
								<lsb>24</lsb>
								<msb>24</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Normal operation  Non dependent loads bypass stores.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 In order operation  Loads always flush preceding stores  processor store buffer disabled.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DIEAR</name>
						<description>CPUx Data Integrity Error Address Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>36896</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>TA</name>
								<description>Transaction Address   TA. Physical address being accessed by operation that encountered data integrity error.</description>
								<lsb>0</lsb>
								<msb>31</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DIETR</name>
						<description>CPUx Data Integrity Error Trap Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>36900</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>IED</name>
								<description>Integrity Error Detected   IED</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Write  Clear IED bit  re enable DIETR and DIEAR update. Read   No data integrity error condition occurred</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Write   No Effect. Read  Data integrity error condition detected. DIETR and DIEAR contents valid  further DIETR and DIEAR updates disabled..</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>IE_T</name>
								<description>Integrity Error   Tag Memory   IE T</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_C</name>
								<description>Integrity Error   Cache Memory   IE C</description>
								<lsb>2</lsb>
								<msb>2</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_S</name>
								<description>Integrity Error   Scratchpad Memory   IE S</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_BI</name>
								<description>Integrity Error   Bus Interface   IE BI</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>E_INFO</name>
								<description>Error Information   E INFO. If IE BS   1  Bus Master Tag ID of requesting masterIf IE C   1  Cache way.</description>
								<lsb>5</lsb>
								<msb>10</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_UNC</name>
								<description>Dual Bit Error Detected   IE UNC</description>
								<lsb>11</lsb>
								<msb>11</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_SP</name>
								<description>Safety Protection Error Detected   IE SP</description>
								<lsb>12</lsb>
								<msb>12</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_BS</name>
								<description>Bus Slave Access Indicator   IE BS</description>
								<lsb>13</lsb>
								<msb>13</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_DLMU</name>
								<description>Integrity Error   DLMU   IE DLMU</description>
								<lsb>14</lsb>
								<msb>14</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_LPB</name>
								<description>Integrity Error   Local Pflash Bank   IE LPB</description>
								<lsb>15</lsb>
								<msb>15</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_MTMV</name>
								<description>Memory Test Mode Violation detected   IE MTMV</description>
								<lsb>16</lsb>
								<msb>16</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PIEAR</name>
						<description>CPUx Program Integrity Error Address Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>37392</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>TA</name>
								<description>Transaction Address   TA. Physical address being accessed by operation that encountered program integrity error.</description>
								<lsb>0</lsb>
								<msb>31</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PIETR</name>
						<description>CPUx Program Integrity Error Trap Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>37396</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>IED</name>
								<description>Integrity Error Detected   IED</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Write  Clear IED bit  re enable PIETR and PIEAR update. Read   No data integrity error condition occurred</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Write   No Effect. Read  Data integrity error condition detected. PIETR and PIEAR contents valid  further PIETR and PIEAR updates disabled..</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>IE_T</name>
								<description>Integrity Error   TAG Memory   IE T</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_C</name>
								<description>Integrity Error   Cache Memory   IE C</description>
								<lsb>2</lsb>
								<msb>2</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_S</name>
								<description>Integrity Error   Scratchpad Memory   IE S</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_BI</name>
								<description>Integrity Error   Bus Interface   IE BI</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>E_INFO</name>
								<description>Error Information   E INFO. If IE BS  1  Bus Master Tag ID of requesting masterIf IE C   1  Cache way.</description>
								<lsb>5</lsb>
								<msb>10</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_UNC</name>
								<description>Integrity Error   Uncorrectable Error Detected   IE UNC</description>
								<lsb>11</lsb>
								<msb>11</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_SP</name>
								<description>Safety Protection Error Detected   IE SP</description>
								<lsb>12</lsb>
								<msb>12</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_BS</name>
								<description>Bus Slave Access Indicator   IE BS</description>
								<lsb>13</lsb>
								<msb>13</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_ADDR</name>
								<description>Address Phase error detected at SRI slave interface   IE ADDR</description>
								<lsb>14</lsb>
								<msb>14</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_LPB</name>
								<description>Integrity Error   Local Pflash bank   IE LPB</description>
								<lsb>15</lsb>
								<msb>15</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>IE_MTMV</name>
								<description>Memory Test Mode Violation detected   IE MTMV</description>
								<lsb>16</lsb>
								<msb>16</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>TASK_ASI</name>
						<description>CPUx Task Address Space Identifier Register
 resetvalue={Application Reset:0x1F}</description>
						<addressOffset>32772</addressOffset>
						<size>32</size>
						<resetValue>31</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>ASI</name>
								<description>Address Space Identifier   ASI. The ASI register contains the Address Space Identifier of the current process.</description>
								<lsb>0</lsb>
								<msb>4</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PMA0</name>
						<description>CPUx Data Access CacheabilityRegister
 resetvalue={Application Reset:0x300}</description>
						<addressOffset>33024</addressOffset>
						<size>32</size>
						<resetValue>768</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>DAC</name>
								<description>Data Access Cacheability Segments FHto 0H   DAC.  Note   segments F H  E H  D H and A H are constrained to be        non cacheable </description>
								<lsb>0</lsb>
								<msb>15</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PMA1</name>
						<description>CPUx Code Access CacheabilityRegister
 resetvalue={Application Reset:0x300}</description>
						<addressOffset>33028</addressOffset>
						<size>32</size>
						<resetValue>768</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CAC</name>
								<description>Code Access Cacheability Segments FH 0H   CAC.  Note  Segments F H  E H  C H  A H are constrained to be non cacheable </description>
								<lsb>0</lsb>
								<msb>15</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PMA2</name>
						<description>CPUx  Peripheral Space Identifier register
 resetvalue={Application Reset:0x0C000}</description>
						<addressOffset>33032</addressOffset>
						<size>32</size>
						<resetValue>49152</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>PSI</name>
								<description>Peripheral Space Identifier Segments FH 0H   PSI</description>
								<lsb>0</lsb>
								<msb>15</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>COMPAT</name>
						<description>CPUx Compatibility Control Register
 resetvalue={Application Reset:0x0FFFFFFFF}</description>
						<addressOffset>37888</addressOffset>
						<size>32</size>
						<resetValue>4294967295</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>RM</name>
								<description>Rounding Mode Compatibility   RM</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 PSW.RM not restored by RET.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 PSW.RM restored by RET  TC1.3 behavior .</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>SP</name>
								<description>SYSCON Safety Protection Mode Compatibility   SP</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 SYSCON 31 1  safety endinit protected.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 SYSCON 31 1  not safety endinit protected  TC1.3 behavior .</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>PCXI</name>
						<description>CPUx Previous Context Information Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65024</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>PCXO</name>
								<description>Previous Context Pointer Offset Field   PCXO. The PCXO and PCXS fields form the pointer PCX  which points to the CSA of the previous context.</description>
								<lsb>0</lsb>
								<msb>15</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>PCXS</name>
								<description>Previous Context Pointer Segment Address   PCXS. Contains the segment address portion of the PCX. This field is used in conjunction with the PCXO field.</description>
								<lsb>16</lsb>
								<msb>19</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>UL</name>
								<description>Upper or Lower Context Tag   UL. Identifies the type of context saved. If the type does not match the type expected when a context restore operation is performed  a trap is generated.</description>
								<lsb>20</lsb>
								<msb>20</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Lower Context</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Upper Context</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>PIE</name>
								<description>Previous Interrupt Enable   PIE. Indicates the state of the interrupt enable bit  ICR.IE  for the interrupted task.</description>
								<lsb>21</lsb>
								<msb>21</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>PCPN</name>
								<description>Previous CPU Priority Number   PCPN. Contains the priority level number of the interrupted task.</description>
								<lsb>22</lsb>
								<msb>29</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PSW</name>
						<description>CPUx Program Status Word
 resetvalue={Application Reset:0x0B80}</description>
						<addressOffset>65028</addressOffset>
						<size>32</size>
						<resetValue>2944</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CDC</name>
								<description>Call Depth Counter   CDC. Consists of two variable width subfields. The first subfield consists of a string of zero or more initial 1 bits  terminated by the first 0 bit. The remaining bits form the second subfield  CDC.COUNT  which constitutes the Call Depth Count value. The count value is incremented on each Call and is decremented on a Return. 0cccccc B   6 bit counter  trap on overflow. 10ccccc B   5 bit counter  trap on overflow. 110cccc B   4 bit counter  trap on overflow. 1110ccc B   3 bit counter  trap on overflow. 11110cc B   2 bit counter  trap on overflow. 111110c B   1 bit counter  trap on overflow. 1111110 B   Trap every call  Call Trace mode . 1111111 B   Disable Call Depth Counting. When the call depth count  CDC.COUNT  overflows a trap  CDO  is generated. Setting the CDC to 1111110 B allows no bits for the counter and causes every call to be trapped. This is used for Call Depth Tracing. Setting the CDC to 1111111 B disables Call Depth Counting.</description>
								<lsb>0</lsb>
								<msb>6</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CDE</name>
								<description>Call Depth Count Enable   CDE. Enables call depth counting  provided that the PSW.CDC mask field is not all set to 1. If PSW.CDC   1111111 B   call depth counting is disabled regardless of the setting on the PSW.CDE bit.</description>
								<lsb>7</lsb>
								<msb>7</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Call depth counting is temporarily disabled. It is automatically re enabled after execution of the next Call instruction.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Call depth counting is enabled.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>IS</name>
								<description>Interrupt Stack Control   IS. Determines if the current execution thread is using the shared global  interrupt  stack or a user stack.</description>
								<lsb>9</lsb>
								<msb>9</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 User Stack.  If an interrupt is taken when the IS bit is 0  then the stack pointer register is loaded from the ISP register before execution starts at the first instruction of the Interrupt Service Routine  ISR .</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Shared Global Stack.  If an interrupt is taken when the PSW.IS bit is 1  then the current value of the stack pointer is used by the Interrupt Service Routine  ISR .</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>IO</name>
								<description>Access Privilege Level Control  I O Privilege    IO. Determines the access level to special function registers and peripheral devices.</description>
								<lsb>10</lsb>
								<msb>11</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>00 User 0 Mode No peripheral access. Access to memory regions with the peripheral space attribute are prohibited and results in a PSE or MPP trap. This access level is given to tasks that need not directly access peripheral devices. Tasks at this level do not have permission to enable or disable interrupts.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>01 User 1 Mode Regular peripheral access. Enables access to common peripheral devices that are not specially protected  including read write access to serial I O ports  read access to timers  and access to most I O status registers. Tasks at this level may disable interrupts.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>10 Supervisor Mode Enables access to all peripheral devices. It enables read write access to core registers and protected peripheral devices. Tasks at this level may disable interrupts.</description>
										<value>2</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>S</name>
								<description>Safe Task Identifier   S</description>
								<lsb>14</lsb>
								<msb>14</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>USB</name>
								<description>User Status Bits   USB. The eight most significant bits of the PSW are designated as User Status Bits. These bits may be set or cleared as side effects of instruction execution. Refer to the TriCore Architecture manual for details.</description>
								<lsb>24</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PC</name>
						<description>CPUx Program Counter
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65032</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>0</resetMask>
						<fields>
							<field>
								<name>PC</name>
								<description>Program Counter   PC</description>
								<lsb>1</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>SYSCON</name>
						<description>CPUx System Configuration Register
 resetvalue={Application Reset:0x0,Application Reset:0x0}</description>
						<addressOffset>65044</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>0</resetMask>
						<fields>
							<field>
								<name>FCDSF</name>
								<description>Free Context List Depleted Sticky Flag   FCDSF. This sticky bit indicates that a FCD  Free Context List Depleted  trap occurred since the bit was last cleared by software.</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 No FCD trap occurred since the last clear.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 An FCD trap occurred since the last clear.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>PROTEN</name>
								<description>Memory Protection Enable   PROTEN. Enables the memory protection system. Memory protection is controlled through the memory protection register        sets. Note  Initialize the protection register sets prior to setting        PROTEN to one.</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Memory Protection is disabled.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Memory Protection is enabled.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>TPROTEN</name>
								<description>Temporal Protection Enable   TPROTEN. Enable the Temporal Protection system.</description>
								<lsb>2</lsb>
								<msb>2</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Temporal Protection is disabled.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Temporal Protection is enabled.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>IS</name>
								<description>Initial State Interrupt   IS. of PSW.S bit in interrupt handle</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>TS</name>
								<description>Initial State Trap   TS. of PSW.S bit in trap handle</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>ESDIS</name>
								<description>Emulator Space Disable. Disable the Emulator Space system</description>
								<lsb>8</lsb>
								<msb>8</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>U1_IED</name>
								<description>User 1 Instruction execution disable   U1 IED. Disable the execution of User 1 mode instructions in User 1 IO mode. Disables User 1 ability to enable and  disable interrupts.</description>
								<lsb>16</lsb>
								<msb>16</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>U1_IOS</name>
								<description>User 1 Peripheral access as supervisor   U1 IOS. Allow User 1 mode tasks to access peripherals as if in Supervisor mode. Enables User 1 access to all  peripheral registers.</description>
								<lsb>17</lsb>
								<msb>17</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>BHALT</name>
								<description>Boot Halt   BHALT</description>
								<lsb>24</lsb>
								<msb>24</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Core is not in boot halt.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Core is in boot halt  write to 0 will exit</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CPU_ID</name>
						<description>CPUx Identification Register TC1.6.2P
 resetvalue={Application Reset:0x0C0C021}</description>
						<addressOffset>65048</addressOffset>
						<size>32</size>
						<resetValue>12632097</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>MOD_REV</name>
								<description>Revision Number   MOD REV</description>
								<lsb>0</lsb>
								<msb>7</msb>
								<access>read-only</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_3232</name>
										<description>20 Reset value</description>
										<value>32</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>MOD_32B</name>
								<description>32 Bit Module Enable   MOD 32B</description>
								<lsb>8</lsb>
								<msb>15</msb>
								<access>read-only</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_192192</name>
										<description>C0 A value of C0 H in this field indicates a 32 bit module with a 32 bit module ID register.</description>
										<value>192</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>MOD</name>
								<description>Module Identification Number   MOD</description>
								<lsb>16</lsb>
								<msb>31</msb>
								<access>read-only</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_192192</name>
										<description>00C0 For module identification.</description>
										<value>192</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CORE_ID</name>
						<description>CPUx Core Identification Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65052</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967288</resetMask>
						<fields>
							<field>
								<name>CORE_ID</name>
								<description>Core Identification Number   CORE ID. The identification number of the core.</description>
								<lsb>0</lsb>
								<msb>2</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>BIV</name>
						<description>CPUx Base Interrupt Vector Table Pointer
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65056</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>VSS</name>
								<description>Vector Spacing Select   VSS. 0  32 byte vector spacing. 1  8 Byte vector spacing.</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>BIV</name>
								<description>Base Address of Interrupt Vector Table   BIV. The address in the BIV register must be aligned to an even byte address  halfword address . Because of the simple ORing of the left shifted priority number and the contents of the BIV register  the alignment of the base address of the vector table must be to a power of two boundary  dependent on the number of interrupt entries used. For the full range of 256 interrupt entries an alignment to an 8 KByte boundary is required. If fewer sources are used  the alignment requirements are correspondingly relaxed.</description>
								<lsb>1</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>BTV</name>
						<description>CPUx Base Trap Vector Table Pointer
 resetvalue={Application Reset:0x0A0000100}</description>
						<addressOffset>65060</addressOffset>
						<size>32</size>
						<resetValue>2684354816</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>BTV</name>
								<description>Base Address of Trap Vector Table   BTV. The address in the BTV register must be aligned to an even byte address  halfword address . Also  due to the simple ORing of the left shifted trap identification number and the contents of the BTV register  the alignment of the base address of the vector table must be to a power of two boundary. There are eight different trap classes  resulting in Trap Classes from 0 to 7. The contents of BTV should therefore be set to at least a 256 byte boundary  8 Trap Classes   8 word spacing .</description>
								<lsb>1</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>ISP</name>
						<description>CPUx Interrupt Stack Pointer
 resetvalue={Application Reset:0x100}</description>
						<addressOffset>65064</addressOffset>
						<size>32</size>
						<resetValue>256</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>ISP</name>
								<description>Interrupt Stack Pointer   ISP</description>
								<lsb>0</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>ICR</name>
						<description>CPUx Interrupt Control Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65068</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CCPN</name>
								<description>Current CPU Priority Number   CCPN. The Current CPU Priority Number  CCPN  bit field indicates the current priority level of the CPU. It is automatically updated by hardware on entry or exit of Interrupt Service Routines  ISRs  and through the execution of a BISR instruction. CCPN can also be updated through an MTCR instruction.</description>
								<lsb>0</lsb>
								<msb>7</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>IE</name>
								<description>Global Interrupt Enable Bit   IE. The interrupt enable bit globally enables the CPU service request system. Whether a service request is delivered to the CPU depends on the individual Service Request Enable Bits  SRE  in the SRNs  and the current state of the CPU. ICR.IE is automatically updated by hardware on entry and exit of an Interrupt Service Routine  ISR . ICR.IE is cleared to 0 when an interrupt is taken  and is restored to the previous value when the ISR executes an RFE instruction to terminate itself. ICR.IE can also be updated through the execution of the ENABLE  DISABLE  MTCR  and BISR instructions.</description>
								<lsb>15</lsb>
								<msb>15</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Interrupt system is globally disabled</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Interrupt system is globally enabled</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>PIPN</name>
								<description>Pending Interrupt Priority Number   PIPN. A read only bit field that is updated by the ICU at the end of each interrupt arbitration process. It indicates the priority number of the pending service request. ICR.PIPN is set to 0 when no request is pending  and at the beginning of each new arbitration process. ...</description>
								<lsb>16</lsb>
								<msb>23</msb>
								<access>read-only</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>00 No valid pending request.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>01 Request pending  lowest priority.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_255255</name>
										<description>FF Request pending  highest priority.</description>
										<value>255</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>FCX</name>
						<description>CPUx Free CSA List Head Pointer
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65080</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>FCXO</name>
								<description>FCX Offset Address Field   FCXO. The FCXO and FCXS fields together form the FCX pointer  which points to the next available CSA.</description>
								<lsb>0</lsb>
								<msb>15</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>FCXS</name>
								<description>FCX Segment Address Field   FCXS. Used in conjunction with the FCXO field.</description>
								<lsb>16</lsb>
								<msb>19</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>LCX</name>
						<description>CPUx Free CSA List Limit Pointer
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65084</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>LCXO</name>
								<description>LCX Offset Field   LCXO. The LCXO and LCXS fields form the pointer LCX  which points to the last available CSA.</description>
								<lsb>0</lsb>
								<msb>15</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>LCXS</name>
								<description>LCX Segment Address   LCXS. This field is used in conjunction with the LCXO field.</description>
								<lsb>16</lsb>
								<msb>19</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>CUS_ID</name>
						<description>CPUx Customer ID register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65104</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967288</resetMask>
						<fields>
							<field>
								<name>CID</name>
								<description>Customer ID   CID. See CROSSREFERENCE for the relation between CUS ID and CORE ID for each derivative</description>
								<lsb>0</lsb>
								<msb>2</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<dim>16</dim>
						<dimIncrement>4</dimIncrement>
						<name>Dy[%s]</name>
						<description>CPUx Data General Purpose Register 0
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65280</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>0</resetMask>
						<fields>
							<field>
								<name>DATA</name>
								<description>Data Register   DATA. General purpose registers</description>
								<lsb>0</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<dim>16</dim>
						<dimIncrement>4</dimIncrement>
						<name>Ay[%s]</name>
						<description>CPUx Address General Purpose Register 0
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>65408</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>0</resetMask>
						<fields>
							<field>
								<name>ADDR</name>
								<description>Address Register   ADDR. General purpose registers</description>
								<lsb>0</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>CPXE_0</name>
						<description>CPUx Code Protection Execute Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57344</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>XE_n</name>
								<description>Execute Enable Range select   XE n </description>
								<lsb>0</lsb>
								<msb>9</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Code Protection        Range n not enabled for execution</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Code Protection        Range n enabled for execution</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CPXE_1</name>
						<description>CPUx Code Protection Execute Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57348</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>XE_n</name>
								<description>Execute Enable Range select   XE n </description>
								<lsb>0</lsb>
								<msb>9</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Code Protection        Range n not enabled for execution</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Code Protection        Range n enabled for execution</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CPXE_2</name>
						<description>CPUx Code Protection Execute Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57352</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>XE_n</name>
								<description>Execute Enable Range select   XE n </description>
								<lsb>0</lsb>
								<msb>9</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Code Protection        Range n not enabled for execution</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Code Protection        Range n enabled for execution</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CPXE_3</name>
						<description>CPUx Code Protection Execute Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57356</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>XE_n</name>
								<description>Execute Enable Range select   XE n </description>
								<lsb>0</lsb>
								<msb>9</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Code Protection        Range n not enabled for execution</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Code Protection        Range n enabled for execution</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPRE_0</name>
						<description>CPUx Data Protection Read Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57360</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>RE_n</name>
								<description>Read Enable Range Select   RE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data read</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data read</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPRE_1</name>
						<description>CPUx Data Protection Read Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57364</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>RE_n</name>
								<description>Read Enable Range Select   RE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data read</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data read</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPRE_2</name>
						<description>CPUx Data Protection Read Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57368</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>RE_n</name>
								<description>Read Enable Range Select   RE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data read</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data read</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPRE_3</name>
						<description>CPUx Data Protection Read Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57372</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>RE_n</name>
								<description>Read Enable Range Select   RE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data read</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data read</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPWE_0</name>
						<description>CPUx Data Protection Write Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57376</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>WE_n</name>
								<description>Write Enable Range Select   WE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data write</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data write</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPWE_1</name>
						<description>CPUx Data Protection Write Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57380</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>WE_n</name>
								<description>Write Enable Range Select   WE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data write</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data write</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPWE_2</name>
						<description>CPUx Data Protection Write Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57384</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>WE_n</name>
								<description>Write Enable Range Select   WE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data write</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data write</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPWE_3</name>
						<description>CPUx Data Protection Write Enable Register Set 3
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57388</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>WE_n</name>
								<description>Write Enable Range Select   WE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data write</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data write</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CPXE_4</name>
						<description>CPUx Code Protection Execute Enable Register Set 5
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57408</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>XE_n</name>
								<description>Execute Enable Range select   XE n </description>
								<lsb>0</lsb>
								<msb>9</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Code Protection        Range n not enabled for execution</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Code Protection        Range n enabled for execution</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CPXE_5</name>
						<description>CPUx Code Protection Execute Enable Register Set 5
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57412</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>XE_n</name>
								<description>Execute Enable Range select   XE n </description>
								<lsb>0</lsb>
								<msb>9</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Code Protection        Range n not enabled for execution</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Code Protection        Range n enabled for execution</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPRE_4</name>
						<description>CPUx Data Protection Read Enable Register Set 5
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57424</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>RE_n</name>
								<description>Read Enable Range Select   RE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data read</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data read</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPRE_5</name>
						<description>CPUx Data Protection Read Enable Register Set 5
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57428</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>RE_n</name>
								<description>Read Enable Range Select   RE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data read</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data read</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPWE_4</name>
						<description>CPUx Data Protection Write Enable Register Set 5
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57440</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>WE_n</name>
								<description>Write Enable Range Select   WE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data write</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data write</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DPWE_5</name>
						<description>CPUx Data Protection Write Enable Register Set 5
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>57444</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>WE_n</name>
								<description>Write Enable Range Select   WE n </description>
								<lsb>0</lsb>
								<msb>17</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Data Protection Range n not enabled for data write</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Data Protection Range n enabled for data write</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CCTRL</name>
						<description>CPUx Counter Control
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64512</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CM</name>
								<description>Counter Mode   CM</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Normal Mode.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Task Mode.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>CE</name>
								<description>Count Enable   CE</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Disable the counters  CCNT  ICNT  M1CNT  M2CNT  M3CNT.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Enable the counters  CCNT  ICNT  M1CNT  M2CNT  M3CNT.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>M1</name>
								<description>M1CNT Configuration   M1</description>
								<lsb>2</lsb>
								<msb>4</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>M2</name>
								<description>M2CNT Configuration   M2</description>
								<lsb>5</lsb>
								<msb>7</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>M3</name>
								<description>M3CNT Configuration   M3</description>
								<lsb>8</lsb>
								<msb>10</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>CCNT</name>
						<description>CPUx CPU Clock Cycle Count
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64516</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CountValue</name>
								<description>Count Value   CountValue. Current Count of the CPU Clock Cycles.</description>
								<lsb>0</lsb>
								<msb>30</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>SOvf</name>
								<description>Sticky Overflow Bit   SOvf. This bit is set by hardware when count value  30 0    31 h7FFF FFFF. It can only be cleared by software.</description>
								<lsb>31</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>ICNT</name>
						<description>CPUx Instruction Count
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64520</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CountValue</name>
								<description>Count Value   CountValue. Count of the Instructions Executed.</description>
								<lsb>0</lsb>
								<msb>30</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>SOvf</name>
								<description>Sticky Overflow Bit   SOvf. This bit is set by hardware when count value  30 0    31 h7FFF FFFF. It can only be cleared by software.</description>
								<lsb>31</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>M1CNT</name>
						<description>CPUx Multi Count Register 1
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64524</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CountValue</name>
								<description>Count Value   CountValue. Count of the Selected Event.</description>
								<lsb>0</lsb>
								<msb>30</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>SOvf</name>
								<description>Sticky Overflow Bit   SOvf. This bit is set by hardware when count value  30 0    31 h7FFF FFFF. It can only be cleared by software.</description>
								<lsb>31</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>M2CNT</name>
						<description>CPUx Multi Count Register 2
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64528</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CountValue</name>
								<description>Count Value   CountValue. Count of the Selected Event.</description>
								<lsb>0</lsb>
								<msb>30</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>SOvf</name>
								<description>Sticky Overflow Bit   SOvf. This bit is set by hardware when count value  30 0    31 h7FFF FFFF. It can only be cleared by software.</description>
								<lsb>31</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>M3CNT</name>
						<description>CPUx Multi Count Register 3
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64532</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>CountValue</name>
								<description>Count Value   CountValue. Count of the Selected Event.</description>
								<lsb>0</lsb>
								<msb>30</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>SOvf</name>
								<description>Sticky Overflow Bit   SOvf. This bit is set by hardware when count value  30 0    31 h7FFF FFFF. It can only be cleared by software.</description>
								<lsb>31</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DBGSR</name>
						<description>CPUx Debug Status Register
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64768</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>DE</name>
								<description>Debug Enable   DE. Determines whether the CDC is enabled or not.</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-only</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 The CDC is disabled.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 The CDC is enabled.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>HALT</name>
								<description>CPU Halt Request   Status Field   HALT. HALT can be set or cleared by software. HALT 0  is the actual Halt bit. HALT 1  is a mask bit to specify whether or not HALT 0  is to be updated on a software write. HALT 1  is always read as 0. HALT 1  must be set to 1 in order to update HALT 0  by software  R  read  W  write .</description>
								<lsb>1</lsb>
								<msb>2</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>00 R  CPU running.  W  HALT 0  unchanged.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>01 R  CPU halted.  W  HALT 0  unchanged.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>10 R  Not Applicable. W  reset HALT 0 .</description>
										<value>2</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_33</name>
										<description>11 R  Not Applicable. W  If DBGSR.DE    1  The CDC is enabled   set HALT 0 . If DBGSR.DE    0  The CDC is not enabled   HALT 0  is left unchanged.</description>
										<value>3</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>SIH</name>
								<description>Suspend in Halt   SIH. State of the Suspend In signal.</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-only</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 The Suspend In signal is negated. The CPU is not in Halt Mode   except when the Halt mechanism is set following a Debug Event or a write to DBGSR.HALT .</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 The Suspend In signal is asserted. The CPU is in Halt Mode.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>SUSP</name>
								<description>Current State of the Core Suspend Out Signal   SUSP</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Core suspend out inactive.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Core suspend out active.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>PREVSUSP</name>
								<description>Previous State of Core Suspend Out Signal   PREVSUSP. Updated when a Debug Event causes a hardware update of DBGSR.SUSP. This field is not updated for writes to DBGSR.SUSP.</description>
								<lsb>6</lsb>
								<msb>6</msb>
								<access>read-only</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Previous core suspend out inactive.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Previous core suspend out active.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>PEVT</name>
								<description>Posted Event   PEVT</description>
								<lsb>7</lsb>
								<msb>7</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 No posted event.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Posted event.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>EXEVT</name>
						<description>CPUx External Event Register
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64776</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>EVTA</name>
								<description>Event Associated   EVTA. Specifies the Debug Action associated with the Debug Event </description>
								<lsb>0</lsb>
								<msb>2</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>000 BOD 0  Disabled. BOD 1  Disabled.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>001 BOD 0  Pulse BRKOUT Signal. BOD 1  None.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>010 BOD 0  Halt and pulse BRKOUT Signal. BOD 1  Halt.</description>
										<value>2</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_33</name>
										<description>011 BOD 0  Breakpoint trap and pulse. BRKOUT Signal. BOD 1  Breakpoint trap.</description>
										<value>3</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_44</name>
										<description>100 BOD 0  Breakpoint interrupt 0 and pulse BRKOUT Signal. BOD 1  Breakpoint interrupt 0.</description>
										<value>4</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_55</name>
										<description>101 BOD 0  If implemented  breakpoint interrupt 1 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 1. If not implemented  None.</description>
										<value>5</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_66</name>
										<description>110 BOD 0  If implemented  breakpoint interrupt 2 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 2. If not implemented  None.</description>
										<value>6</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_77</name>
										<description>111 BOD 0  If implemented  breakpoint interrupt 3 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 3. If not implemented  None.</description>
										<value>7</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>BBM</name>
								<description>Break Before Make  BBM  or Break After Make  BAM  Selection   BBM</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Break after make  BAM .</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Break before make  BBM .</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>BOD</name>
								<description>Breakout Disable   BOD</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 BRKOUT signal asserted according to the Debug Action specified in the EVTA field.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 BRKOUT signal not asserted. This takes priority over any assertion generated by the EVTA field.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>SUSP</name>
								<description>CDC Suspend Out Signal State   SUSP. Value to be assigned to the CDC suspend out signal when the Debug Event is raised.</description>
								<lsb>5</lsb>
								<msb>5</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CNT</name>
								<description>Counter   CNT. When this event occurs adjust the control of the performance counters in task mode as follows </description>
								<lsb>6</lsb>
								<msb>7</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>00 No change.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>01 Start the performance counters.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>10 Stop the performance counters.</description>
										<value>2</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_33</name>
										<description>11 Toggle the performance counter control  i.e. start it if it is currently stopped  stop it if it is currently running .</description>
										<value>3</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>CREVT</name>
						<description>CPUx Core Register Access Event
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64780</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>EVTA</name>
								<description>Event Associated   EVTA. Debug Action associated with the Debug Event </description>
								<lsb>0</lsb>
								<msb>2</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>000 BOD 0  Disabled. BOD 1  Disabled.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>001 BOD 0  Pulse BRKOUT Signal. BOD 1  None.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>010 BOD 0  Halt and pulse BRKOUT Signal. BOD 1  Halt.</description>
										<value>2</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_33</name>
										<description>011 BOD 0  Breakpoint trap and pulse BRKOUT Signal. BOD 1  Breakpoint trap.</description>
										<value>3</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_44</name>
										<description>100 BOD 0  Breakpoint interrupt 0 and pulse BRKOUT Signal. BOD 1  Breakpoint interrupt 0.</description>
										<value>4</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_55</name>
										<description>101 BOD 0  If implemented  breakpoint interrupt 1 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 1. If not implemented  None.</description>
										<value>5</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_66</name>
										<description>110 BOD 0  If implemented  breakpoint interrupt 2 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 2. If not implemented  None.</description>
										<value>6</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_77</name>
										<description>111 BOD 0  If implemented  breakpoint interrupt 3 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 3. If not implemented  None.</description>
										<value>7</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>BBM</name>
								<description>Break Before Make  BBM  or Break After Make  BAM  Selection   BBM</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Break after make  BAM .</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Break before make  BBM .</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>BOD</name>
								<description>Breakout Disable   BOD</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 BRKOUT signal asserted according to the action specified in the EVTA field.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 BRKOUT signal not asserted. This takes priority over any assertion generated by the EVTA field.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>SUSP</name>
								<description>CDC Suspend Out Signal State   SUSP. Value to be assigned to the CDC suspend out signal when the Debug Event is raised.</description>
								<lsb>5</lsb>
								<msb>5</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CNT</name>
								<description>Counter   CNT. When this event occurs adjust the control of the performance counters in task mode as follows </description>
								<lsb>6</lsb>
								<msb>7</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>00 No change.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>01 Start the performance counters.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>10 Stop the performance counters.</description>
										<value>2</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_33</name>
										<description>11 Toggle the performance counter control  i.e. start it if it is currently stopped  stop it if it is currently running .</description>
										<value>3</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>SWEVT</name>
						<description>CPUx Software Debug Event
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64784</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>EVTA</name>
								<description>Event Associated   EVTA. Debug Action associated with the Debug Event </description>
								<lsb>0</lsb>
								<msb>2</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>000 BOD 0  Disabled. BOD 1  Disabled.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>001 BOD 0  Pulse BRKOUT Signal. BOD 1  None.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>010 BOD 0  Halt and pulse BRKOUT Signal. BOD 1  Halt.</description>
										<value>2</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_33</name>
										<description>011 BOD 0  Breakpoint trap and pulse BRKOUT Signal. BOD 1  Breakpoint trap.</description>
										<value>3</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_44</name>
										<description>100 BOD 0  Breakpoint interrupt 0 and pulse BRKOUT Signal. BOD 1  Breakpoint interrupt 0.</description>
										<value>4</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_55</name>
										<description>101 BOD 0  If implemented  breakpoint interrupt 1 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 1. If not implemented  None.</description>
										<value>5</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_66</name>
										<description>110 BOD 0  If implemented  breakpoint interrupt 2 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 2. If not implemented  None.</description>
										<value>6</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_77</name>
										<description>111 BOD 0  If implemented  breakpoint interrupt 3 and pulse BRKOUT Signal. BOD 1  If implemented  breakpoint interrupt 3. If not implemented  None.</description>
										<value>7</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>BBM</name>
								<description>Break Before Make  BBM  or Break After Make  BAM  Selection   BBM</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Break after make  BAM .</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Break before make  BBM .</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>BOD</name>
								<description>Breakout Disable   BOD</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 BRKOUT signal asserted according to the action specified in the EVTA field.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 BRKOUT signal not asserted. This takes priority over any assertion generated by the EVTA field.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>SUSP</name>
								<description>CDC Suspend Out Signal State   SUSP. Value to be assigned to the CDC suspend out signal when the event is raised.</description>
								<lsb>5</lsb>
								<msb>5</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CNT</name>
								<description>Counter   CNT. When this event occurs adjust the control of the performance counters in task mode as follows </description>
								<lsb>6</lsb>
								<msb>7</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>00 No change.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>01 Start the performance counters.</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>10 Stop the performance counters.</description>
										<value>2</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_33</name>
										<description>11 Toggle the performance counter control  i.e. start it if it is currently stopped  stop it if it is currently running .</description>
										<value>3</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>TRIG_ACC</name>
						<description>CPUx TriggerAddressx
 resetvalue={Debug Reset:0x0}</description>
						<addressOffset>64816</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>T0</name>
								<description>Trigger 0   T0. active since last cleared</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>T1</name>
								<description>Trigger 1   T1. active since last cleared</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>T2</name>
								<description>Trigger 2   T2. active since last cleared</description>
								<lsb>2</lsb>
								<msb>2</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>T3</name>
								<description>Trigger 3   T3. active since last cleared</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>T4</name>
								<description>Trigger 4   T4. active since last cleared</description>
								<lsb>4</lsb>
								<msb>4</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>T5</name>
								<description>Trigger 5   T5. active since last cleared</description>
								<lsb>5</lsb>
								<msb>5</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>T6</name>
								<description>Trigger 6   T6. active since last cleared</description>
								<lsb>6</lsb>
								<msb>6</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>T7</name>
								<description>Trigger 7   T7. active since last cleared</description>
								<lsb>7</lsb>
								<msb>7</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DMS</name>
						<description>CPUx Debug Monitor Start Address
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>64832</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>0</resetMask>
						<fields>
							<field>
								<name>DMSValue</name>
								<description>Debug Monitor Start Address   DMSValue. The address at which monitor code execution begins when a breakpoint trap is taken.</description>
								<lsb>1</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DCX</name>
						<description>CPUx Debug Context Save Area Pointer
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>64836</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>0</resetMask>
						<fields>
							<field>
								<name>DCXValue</name>
								<description>Debug Context Save Area Pointer   DCXValue. Address where the debug context is stored following a breakpoint trap.</description>
								<lsb>6</lsb>
								<msb>31</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DBGTCR</name>
						<description>CPUx Debug Trap Control Register
 resetvalue={Application Reset:0x1}</description>
						<addressOffset>64840</addressOffset>
						<size>32</size>
						<resetValue>1</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>DTA</name>
								<description>Debug Trap Active Bit   DTA. A breakpoint trap may only be taken in the condition DTA    0. Taking a breakpoint trap sets the DTA bit to one. Further breakpoint traps are therefore disabled until such time as the breakpoint trap handler clears the DTA bit or until the breakpoint trap handler terminates with a RFM.</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 No breakpoint trap is active.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 A breakpoint Trap is active</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>SEGEN</name>
						<description>CPUx SRI Error Generation Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>4144</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>ADFLIP</name>
								<description>Address ECC Bit Flip   ADFLIP. SRI address ECC Bits to be flipped on the next read or write transaction from the DMI when enabled by AE.</description>
								<lsb>0</lsb>
								<msb>7</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 No Flip</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Flip</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>ADTYPE</name>
								<description>Type of error   ADTYPE</description>
								<lsb>8</lsb>
								<msb>9</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>00 Data Master Address Phase</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>01 Data Master Write Data</description>
										<value>1</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_22</name>
										<description>10 Data Slave Read Data</description>
										<value>2</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>AE</name>
								<description>Activate Error Enable   AE. Enabled the selective inverting of SRI ECC packet bits defined by ADFLIP. This bit will be cleared by hardware after the next SRI read or write transaction from the DMI.</description>
								<lsb>31</lsb>
								<msb>31</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Not Enabled</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Enabled</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>DCON2</name>
						<description>CPUx Data Control Register 2
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>36864</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>0</resetMask>
						<fields>
							<field>
								<name>DCACHE_SZE</name>
								<description>Data Cache Size   DCACHE SZE. In KBytes</description>
								<lsb>0</lsb>
								<msb>15</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>DSCRATCH_SZE</name>
								<description>Data Scratch Size   DSCRATCH SZE. In KBytes</description>
								<lsb>16</lsb>
								<msb>31</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DSTR</name>
						<description>CPUx Data Synchronous Trap Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>36880</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>SRE</name>
								<description>Scratch Range Error   SRE. A scratch Range Error occurs whenever an access to the data scratch is outside the range of the SRAM.</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>GAE</name>
								<description>Global Address Error   GAE. Load or store to local code scratch address outside of the lower 1MByte.</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>LBE</name>
								<description>Load Bus Error   LBE. A Load Bus Error will be set whenever the SRI flags an error due a load from external memory.</description>
								<lsb>2</lsb>
								<msb>2</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>DRE</name>
								<description>Local DLMU Range Error   DRE. A DLMU Range Error occurs whenever an access to the local DLMU region is outside the physically implemented memory.</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CRE</name>
								<description>Cache Refill Error   CRE. A Cache Refill Error will be set whenever the SRI flags an error due a cache refill from external memory.</description>
								<lsb>6</lsb>
								<msb>6</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>DTME</name>
								<description>DTAG MSIST Error   DTME. Access to memory mapped DTAG range outside of physically implemented memory.</description>
								<lsb>14</lsb>
								<msb>14</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>LOE</name>
								<description>Load Overlay Error   LOE. Load to invalid overlay address.</description>
								<lsb>15</lsb>
								<msb>15</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>SDE</name>
								<description>Segment Difference Error   SDE. Load or store access where base address is in different segment to access address.</description>
								<lsb>16</lsb>
								<msb>16</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>SCE</name>
								<description>Segment Crossing Error   SCE. Load or store access across segment boundary.</description>
								<lsb>17</lsb>
								<msb>17</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CAC</name>
								<description>CSFR Access Error   CAC. Load or store to local CSFR space.</description>
								<lsb>18</lsb>
								<msb>18</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>MPE</name>
								<description>Memory Protection Error   MPE. Data access violating memory protection.</description>
								<lsb>19</lsb>
								<msb>19</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CLE</name>
								<description>Context Location Error   CLE. Context operation to invalid location.</description>
								<lsb>20</lsb>
								<msb>20</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>ALN</name>
								<description>Alignment Error   ALN. Data access causing alignment error.</description>
								<lsb>24</lsb>
								<msb>24</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DATR</name>
						<description>CPUx Data Asynchronous Trap Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>36888</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>SBE</name>
								<description>Store Bus Error   SBE</description>
								<lsb>3</lsb>
								<msb>3</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CWE</name>
								<description>Cache Writeback Error   CWE</description>
								<lsb>9</lsb>
								<msb>9</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>CFE</name>
								<description>Cache Flush Error   CFE</description>
								<lsb>10</lsb>
								<msb>10</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>SOE</name>
								<description>Store Overlay Error   SOE</description>
								<lsb>14</lsb>
								<msb>14</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DEADD</name>
						<description>CPUx Data Error Address Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>36892</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>ERROR_ADDRESS</name>
								<description>Error Address   ERROR ADDRESS</description>
								<lsb>0</lsb>
								<msb>31</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>DCON0</name>
						<description>CPUx Data Memory Control Register
 resetvalue={Application Reset:0x2}</description>
						<addressOffset>36928</addressOffset>
						<size>32</size>
						<resetValue>2</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>DCBYP</name>
								<description>Data Cache Bypass   DCBYP</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 DCache   DRB enabled</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 DCache   DRB Bypass  disabled </description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>PSTR</name>
						<description>CPUx Program Synchronous Trap Register
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>37376</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>FRE</name>
								<description>Fetch Range Error   FRE. A Fetch Range Error occurs whenever an access to the Program Scratch is outside the range of the SRAM.</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>FBE</name>
								<description>Fetch Bus Error   FBE. A Fetch bus error will be set whenever the SRI flags an error due a fetch from external memory. This will be set for both direct fetches from the bus and for cache refills.</description>
								<lsb>2</lsb>
								<msb>2</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>FPE</name>
								<description>Fetch Peripheral Error   FPE. A Fetch peripheral error will be flagged whenever a fetch is attempted to peripheral space.</description>
								<lsb>12</lsb>
								<msb>12</msb>
								<access>read-write</access>
							</field>
							<field>
								<name>FME</name>
								<description>Fetch MSIST Error   FME. During SIST mode  a fetch from the PTAG will cause a PSE trap to occur.</description>
								<lsb>14</lsb>
								<msb>14</msb>
								<access>read-write</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PCON1</name>
						<description>CPUx Program Control 1
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>37380</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>PCINV</name>
								<description>Program Cache Invalidate   PCINV</description>
								<lsb>0</lsb>
								<msb>0</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Write  No effect  normal instruction cache operation. Read   Normal operation  instruction cache available</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Write   Initiate invalidation of entire instruction cache. Read  Instruction cache invalidation in progress. Instruction cache unavailable.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
							<field>
								<name>PBINV</name>
								<description>Program Buffer Invalidate   PBINV. Write Operation  This field returns 0 when read.</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Write  No effect. Normal program line buffer operation.</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Write  Invalidate the program line buffer.</description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
					<register>
						<name>PCON2</name>
						<description>CPUx Program Control 2
 resetvalue={Application Reset:0x0}</description>
						<addressOffset>37384</addressOffset>
						<size>32</size>
						<resetValue>0</resetValue>
						<resetMask>0</resetMask>
						<fields>
							<field>
								<name>PCACHE_SZE</name>
								<description>Program Cache Size  ICACHE  in KBytes   PCACHE SZE. In KBytes</description>
								<lsb>0</lsb>
								<msb>15</msb>
								<access>read-only</access>
							</field>
							<field>
								<name>PSCRATCH_SZE</name>
								<description>Program Scratch Size in KBytes   PSCRATCH SZE. In KBytes</description>
								<lsb>16</lsb>
								<msb>31</msb>
								<access>read-only</access>
							</field>
						</fields>
					</register>
					<register>
						<name>PCON0</name>
						<description>CPUx Program Control 0
 resetvalue={Application Reset:0x2}</description>
						<addressOffset>37388</addressOffset>
						<size>32</size>
						<resetValue>2</resetValue>
						<resetMask>4294967295</resetMask>
						<fields>
							<field>
								<name>PCBYP</name>
								<description>Program Cache Bypass   PCBYP</description>
								<lsb>1</lsb>
								<msb>1</msb>
								<access>read-write</access>
								<enumeratedValues>
									<enumeratedValue>
										<name>Const_00</name>
										<description>0 Cache enabled</description>
										<value>0</value>
									</enumeratedValue>
									<enumeratedValue>
										<name>Const_11</name>
										<description>1 Cache bypass  disabled </description>
										<value>1</value>
									</enumeratedValue>
								</enumeratedValues>
							</field>
						</fields>
					</register>
				</registers>
			</peripheral>
		</aurixCSFR>
	</vendorExtensions>
</device>